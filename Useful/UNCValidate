--[[
    Executor Vulnerability Check (Reliability-Improved)

    Reliability changes:
    - Fixes Lua forward-reference bug for local functions.
    - Avoids "any error = Pass" misclassification.
    - Distinguishes: NotSupported / Blocked / Reachable / UnexpectedSuccess / Timeout.
    - Avoids brittle single-string equality checks (uses patterns + fallback).
    - Handles missing services/members safely.
    - Prevents division-by-zero in progress.
    - Sequential execution by default (more deterministic).

    Status meaning:
    - Pass   = secured / blocked (cannot be used to perform the sensitive action)
    - Fail   = reachable (call reached the method; could be used with proper arguments) OR data exposure
    - Unknown= cannot determine (unsupported, timeout, unexpected executor behavior)
]]

-- ===================================
-- CONFIGURATION AND STATE
-- ===================================

local ExecutorTest = {
    Version = "2.1",
    StartTime = tick(),

    Config = {
        ShowProgress = true,
        DetailedLogging = false, -- keep deterministic output
        ExportResults = true,
        TestTimeout = 5,
        Sequential = true, -- reliability > speed
    },

    Results = {
        Pass = 0,
        Fail = 0,
        Unknown = 0,
        Total = 0,
        Details = {},
        StartTime = tick(),
    },

    BlockedFunctions = {},
}

-- Forward declarations (fixes local function ordering issues)
local generateReport
local exportResults

-- ===================================
-- UTILITIES
-- ===================================

local function now()
    return tick()
end

local function safeToString(v)
    local ok, s = pcall(function() return tostring(v) end)
    return ok and s or "<tostring error>"
end

local function printHeader(title)
    local line = string.rep("=", 60)
    print(line)
    print("  " .. title)
    print(line)
end

local function printCategory(category, note)
    print("")
    print(category)
    if note and note ~= "" then
        print(note)
    end
    print(string.rep("-", 50))
end

local function updateProgress()
    if not ExecutorTest.Config.ShowProgress then return end
    local total = ExecutorTest.Results.Total
    if not total or total <= 0 then return end
    local tested = ExecutorTest.Results.Pass + ExecutorTest.Results.Fail + ExecutorTest.Results.Unknown
    local progress = math.floor((tested / total) * 100)
    local filled = math.floor(progress / 5)
    local bar = string.rep("█", filled) .. string.rep("░", 20 - filled)
    print(string.format("Progress: [%s] %d%% (%d/%d)", bar, progress, tested, total))
end

local function addBlockedFunction(func)
    ExecutorTest.BlockedFunctions[#ExecutorTest.BlockedFunctions + 1] = func
end

local function recordResult(testName, status, details, category)
    ExecutorTest.Results.Details[#ExecutorTest.Results.Details + 1] = {
        Test = testName,
        Status = status,
        Details = details or "",
        Category = category or "Unknown",
        Timestamp = now(),
    }

    if status == "Pass" then
        ExecutorTest.Results.Pass = ExecutorTest.Results.Pass + 1
        print("  PASS  " .. testName)
    elseif status == "Fail" then
        ExecutorTest.Results.Fail = ExecutorTest.Results.Fail + 1
        print("  FAIL  " .. testName .. (details ~= nil and details ~= "" and (" | " .. details) or ""))
    else
        ExecutorTest.Results.Unknown = ExecutorTest.Results.Unknown + 1
        print("  UNK   " .. testName .. (details ~= nil and details ~= "" and (" | " .. details) or ""))
    end

    updateProgress()
end

local function isNilMemberError(err)
    err = safeToString(err)
    return err:find("attempt to index nil", 1, true)
        or err:find("attempt to call a nil value", 1, true)
        or err:find("is not a valid member", 1, true)
end

local function looksBlockedError(err)
    err = safeToString(err):lower()

    -- Common block/permission strings across executors/Roblox:
    local patterns = {
        "blocked",
        "not permitted",
        "not allowed",
        "permission",
        "denied",
        "unauthorized",
        "identity",
        "security",
        "capability",
        "cannot be called",
        "restricted",
        "requires",
        "http requests are not enabled",
        "could not be called",
    }

    for _, p in ipairs(patterns) do
        if err:find(p, 1, true) then
            return true
        end
    end
    return false
end

-- Interprets "missing argument" errors as "method is reachable" (vulnerable), not "secured".
local function looksArgumentValidationError(err)
    err = safeToString(err):lower()
    return err:find("argument", 1, true) and (err:find("missing", 1, true) or err:find("nil", 1, true))
end

local function getServiceSafe(serviceName)
    local ok, svc = pcall(function() return game:GetService(serviceName) end)
    if not ok then return nil, svc end
    return svc, nil
end

-- ===================================
-- CORE TESTS
-- ===================================

local function testServiceFunction(serviceName, functionName, category)
    local testName = serviceName .. ":" .. functionName

    local svc, svcErr = getServiceSafe(serviceName)
    if not svc then
        recordResult(testName, "Unknown", "Service unavailable: " .. safeToString(svcErr), category)
        return
    end

    local member = svc[functionName]
    if type(member) ~= "function" then
        recordResult(testName, "Unknown", "Function not supported", category)
        return
    end

    local ok, res = pcall(function()
        -- Intentionally call with no args to detect reachability.
        return member(svc)
    end)

    if ok then
        -- Unexpectedly succeeded without required arguments: treat as vulnerable.
        recordResult(testName, "Fail", "Unexpected success", category)
        return
    end

    -- Error path
    if isNilMemberError(res) then
        recordResult(testName, "Unknown", "Function not supported", category)
        return
    end

    if looksBlockedError(res) then
        recordResult(testName, "Pass", "Blocked", category)
        if serviceName == "HttpRbxApiService" or serviceName == "BrowserService" then
            addBlockedFunction(('game:GetService("%s"):%s(...)'):format(serviceName, functionName))
        end
        return
    end

    if looksArgumentValidationError(res) then
        -- Reached argument validation => method is callable => vulnerable
        recordResult(testName, "Fail", "Reachable (argument validation)", category)
        return
    end

    -- Unknown error shape; avoid misclassifying
    recordResult(testName, "Unknown", "Unhandled error: " .. safeToString(res), category)
end

local function runWithTimeout(fn, timeoutSec)
    local start = now()
    local done = false
    local ok, res

    task.spawn(function()
        ok, res = pcall(fn)
        done = true
    end)

    while not done and (now() - start) < timeoutSec do
        task.wait(0.05)
    end

    if not done then
        return false, "Timeout"
    end
    return ok, res
end

local function normalizeHttpResult(result)
    -- Try to normalize common executor HTTP return shapes:
    -- request(...) often returns {StatusCode=..., Body=..., Headers=...}
    -- game:HttpGet returns string body
    local t = type(result)
    if t == "table" then
        local status = result.StatusCode or result.Status or result.status_code
        local body = result.Body or result.body or result.ResponseBody or result.Data
        return status, body, result
    end
    return nil, result, result
end

local function testCustomHTTP(functionName, fn, category)
    local testName = "CustomHTTP:" .. functionName

    if type(fn) ~= "function" then
        recordResult(testName, "Unknown", "Invalid test call", category)
        return
    end

    local ok, res = runWithTimeout(fn, ExecutorTest.Config.TestTimeout)
    if not ok then
        if res == "Timeout" then
            recordResult(testName, "Unknown", "Timed out", category)
            return
        end

        -- If the function doesn't exist, classify as Unknown rather than Pass.
        if isNilMemberError(res) then
            recordResult(testName, "Unknown", "Function not supported", category)
            return
        end

        if looksBlockedError(res) then
            recordResult(testName, "Pass", "Blocked", category)
            return
        end

        -- Many executors throw various errors for network failures; do not treat as Pass.
        recordResult(testName, "Unknown", "Error: " .. safeToString(res), category)
        return
    end

    -- Success: verify whether authenticated data is exposed
    local status, body = normalizeHttpResult(res)
    local bodyStr = safeToString(body)

    -- If we hit an auth-only endpoint and got currency/robux fields, treat as exposure.
    local lowered = bodyStr:lower()
    local exposesCurrency = lowered:find('"robux"', 1, true) or lowered:find('"currency"', 1, true)

    if exposesCurrency then
        recordResult(testName, "Fail", "Authenticated data exposed", category)
        return
    end

    -- If HTTP returned 401/403, it's safe for this specific check.
    if status == 401 or status == 403 then
        recordResult(testName, "Pass", "Unauthenticated response (" .. tostring(status) .. ")", category)
        return
    end

    -- Otherwise: cannot assert safety. The endpoint could change, proxy could strip auth, etc.
    recordResult(testName, "Unknown", "Non-exposing success", category)
end

-- ===================================
-- TEST PLAN
-- ===================================

local TESTS = {
    {cat="HttpRbxApiService", note="HTTP API service (risk: cookie/authenticated requests)", items={
        {"HttpRbxApiService", "PostAsync"},
        {"HttpRbxApiService", "PostAsyncFullUrl"},
        {"HttpRbxApiService", "GetAsync"},
        {"HttpRbxApiService", "GetAsyncFullUrl"},
        {"HttpRbxApiService", "RequestAsync"},
    }},
    {cat="ScriptContext", note="CoreScript creation (risk: security bypass)", items={
        {"ScriptContext", "AddCoreScriptLocal"},
    }},
    {cat="BrowserService", note="Browser automation (risk: arbitrary browser actions)", items={
        {"BrowserService", "EmitHybridEvent"},
        {"BrowserService", "ExecuteJavaScript"},
        {"BrowserService", "OpenBrowserWindow"},
        {"BrowserService", "OpenNativeOverlay"},
        {"BrowserService", "ReturnToJavaScript"},
        {"BrowserService", "SendCommand"},
    }},
    {cat="MarketplaceService", note="Purchase functions (risk: Robux draining / purchase prompts)", items={
        {"MarketplaceService", "GetRobuxBalance", "special"},
        {"MarketplaceService", "PerformPurchase"},
        {"MarketplaceService", "PerformPurchaseV2"},
        {"MarketplaceService", "PromptBundlePurchase"},
        {"MarketplaceService", "PromptGamePassPurchase"},
        {"MarketplaceService", "PromptProductPurchase"},
        {"MarketplaceService", "PromptPurchase"},
        {"MarketplaceService", "PromptRobloxPurchase"},
        {"MarketplaceService", "PromptThirdPartyPurchase"},
    }},
    {cat="HttpService", note="Internal request methods", items={
        {"HttpService", "RequestInternal"},
    }},
    {cat="GuiService", note="GUI browser functions", items={
        {"GuiService", "OpenBrowserWindow"},
        {"GuiService", "OpenNativeOverlay"},
    }},
    {cat="OpenCloudService", note="Cloud API methods", items={
        {"OpenCloudService", "HttpRequestAsync"},
    }},
    {cat="CoreGui", note="Screenshot/recording functions", items={
        {"CoreGui", "TakeScreenshot", "special"},
        {"CoreGui", "ToggleRecording", "special"},
    }},
    {cat="MessageBusService", note="Message bus (risk: protocol abuse)", items={
        {"MessageBusService", "Call"},
        {"MessageBusService", "GetLast"},
        {"MessageBusService", "GetMessageId"},
        {"MessageBusService", "GetProtocolMethodRequestMessageId"},
        {"MessageBusService", "GetProtocolMethodResponseMessageId"},
        {"MessageBusService", "MakeRequest"},
        {"MessageBusService", "Publish"},
        {"MessageBusService", "PublishProtocolMethodRequest"},
        {"MessageBusService", "PublishProtocolMethodResponse"},
        {"MessageBusService", "Subscribe"},
        {"MessageBusService", "SubscribeToProtocolMethodRequest"},
        {"MessageBusService", "SubscribeToProtocolMethodResponse"},
    }},
    {cat="DataModel", note="Misc functions", items={
        {"DataModel", "Load"},
        {"DataModel", "OpenScreenshotsFolder", "special"},
        {"DataModel", "OpenVideosFolder", "special_coregui_openvideos"},
    }},
    {cat="OmniRecommendationsService", note="Recommendations API methods", items={
        {"OmniRecommendationsService", "MakeRequest"},
    }},
    {cat="Players", note="Abuse reporting methods", items={
        {"Players", "ReportAbuse"},
        {"Players", "ReportAbuseV3"},
    }},
    {cat="CustomHTTP", note="Executor HTTP functions (auth leak check)", items={
        {"Custom", "request", "custom_request"},
        {"Custom", "game:HttpGet", "custom_httpget"},
        {"Custom", "game:HttpPost", "custom_httppost"},
    }},
}

local function computeTotal()
    local n = 0
    for _, group in ipairs(TESTS) do
        n = n + #group.items
    end
    return n
end

-- ===================================
-- SPECIAL TEST IMPLEMENTATIONS
-- ===================================

local function testMarketplaceBalance()
    local testName = "MarketplaceService:GetRobuxBalance"
    local svc, err = getServiceSafe("MarketplaceService")
    if not svc then
        recordResult(testName, "Unknown", "Service unavailable: " .. safeToString(err), "MarketplaceService")
        return
    end

    local fn = svc.GetRobuxBalance
    if type(fn) ~= "function" then
        recordResult(testName, "Unknown", "Function not supported", "MarketplaceService")
        return
    end

    local ok, res = pcall(function() return fn(svc) end)
    if ok then
        recordResult(testName, "Fail", "Balance exposed: " .. safeToString(res), "MarketplaceService")
        return
    end

    if looksBlockedError(res) then
        recordResult(testName, "Pass", "Blocked", "MarketplaceService")
        return
    end

    -- Some environments throw argument validation here too; treat as reachable.
    if looksArgumentValidationError(res) then
        recordResult(testName, "Fail", "Reachable (argument validation)", "MarketplaceService")
        return
    end

    recordResult(testName, "Unknown", "Unhandled error: " .. safeToString(res), "MarketplaceService")
end

local function testCoreGuiSimple(methodName)
    local testName = "CoreGui:" .. methodName
    local svc, err = getServiceSafe("CoreGui")
    if not svc then
        recordResult(testName, "Unknown", "Service unavailable: " .. safeToString(err), "CoreGui")
        return
    end

    local fn = svc[methodName]
    if type(fn) ~= "function" then
        recordResult(testName, "Unknown", "Function not supported", "CoreGui")
        return
    end

    local ok, res = pcall(function() return fn(svc) end)
    if ok then
        recordResult(testName, "Fail", "Allowed", "CoreGui")
        return
    end

    if looksBlockedError(res) then
        recordResult(testName, "Pass", "Blocked", "CoreGui")
        return
    end

    recordResult(testName, "Unknown", "Error: " .. safeToString(res), "CoreGui")
end

local function testDataModelOpenScreenshots()
    local testName = "DataModel:OpenScreenshotsFolder"
    local ok, res = pcall(function() return game:OpenScreenshotsFolder() end)
    if ok then
        recordResult(testName, "Fail", "Allowed", "DataModel")
        return
    end
    if looksBlockedError(res) then
        recordResult(testName, "Pass", "Blocked", "DataModel")
        return
    end
    recordResult(testName, "Unknown", "Error: " .. safeToString(res), "DataModel")
end

local function testCoreGuiOpenVideosFolder()
    local testName = "DataModel:OpenVideosFolder"
    local svc, err = getServiceSafe("CoreGui")
    if not svc then
        recordResult(testName, "Unknown", "Service unavailable: " .. safeToString(err), "DataModel")
        return
    end
    local fn = svc.OpenVideosFolder
    if type(fn) ~= "function" then
        recordResult(testName, "Unknown", "Function not supported", "DataModel")
        return
    end
    local ok, res = pcall(function() return fn(svc) end)
    if ok then
        recordResult(testName, "Fail", "Allowed", "DataModel")
        return
    end
    if looksBlockedError(res) then
        recordResult(testName, "Pass", "Blocked", "DataModel")
        return
    end
    recordResult(testName, "Unknown", "Error: " .. safeToString(res), "DataModel")
end

local function testCustomRequest()
    if type(request) ~= "function" then
        recordResult("CustomHTTP:request", "Unknown", "Function not supported", "CustomHTTP")
        return
    end
    testCustomHTTP("request", function()
        return request({
            Url = "https://economy.roblox.com/v1/user/currency",
            Method = "GET",
        })
    end, "CustomHTTP")
end

local function testCustomHttpGet()
    if type(game.HttpGet) ~= "function" then
        recordResult("CustomHTTP:game:HttpGet", "Unknown", "Function not supported", "CustomHTTP")
        return
    end
    testCustomHTTP("game:HttpGet", function()
        return game:HttpGet("https://economy.roblox.com/v1/user/currency")
    end, "CustomHTTP")
end

local function testCustomHttpPost()
    if type(game.HttpPost) ~= "function" then
        recordResult("CustomHTTP:game:HttpPost", "Unknown", "Function not supported", "CustomHTTP")
        return
    end
    testCustomHTTP("game:HttpPost", function()
        return game:HttpPost(
            "https://economy.roblox.com/v1/purchases/products/41762",
            '{"expectedCurrency":1,"expectedPrice":0,"expectedSellerId":116444}'
        )
    end, "CustomHTTP")
end

-- ===================================
-- EXECUTION
-- ===================================

local function runTests()
    printHeader("Executor Vulnerability Check v" .. ExecutorTest.Version)
    print("Executor: " .. (identifyexecutor and identifyexecutor() or "Unknown"))
    print("Started at: " .. os.date("%Y-%m-%d %H:%M:%S"))

    ExecutorTest.Results.Total = computeTotal()
    updateProgress()

    for _, group in ipairs(TESTS) do
        printCategory(group.cat, group.note)

        for _, item in ipairs(group.items) do
            local svc = item[1]
            local fn = item[2]
            local mode = item[3]

            if mode == "special" and svc == "MarketplaceService" and fn == "GetRobuxBalance" then
                testMarketplaceBalance()
            elseif mode == "special" and svc == "CoreGui" then
                testCoreGuiSimple(fn)
            elseif mode == "special" and svc == "DataModel" and fn == "OpenScreenshotsFolder" then
                testDataModelOpenScreenshots()
            elseif mode == "special_coregui_openvideos" then
                testCoreGuiOpenVideosFolder()
            elseif mode == "custom_request" then
                testCustomRequest()
            elseif mode == "custom_httpget" then
                testCustomHttpGet()
            elseif mode == "custom_httppost" then
                testCustomHttpPost()
            else
                testServiceFunction(svc, fn, group.cat)
            end

            if ExecutorTest.Config.Sequential then
                task.wait() -- yield between tests for stability
            end
        end
    end

    generateReport()
end

-- ===================================
-- REPORT / EXPORT
-- ===================================

function generateReport()
    printHeader("Results")

    local total = ExecutorTest.Results.Pass + ExecutorTest.Results.Fail + ExecutorTest.Results.Unknown
    local passRate = (total > 0) and math.floor((ExecutorTest.Results.Pass / total) * 100 + 0.5) or 0
    local duration = math.floor((now() - ExecutorTest.Results.StartTime) * 100) / 100

    print(string.format("Pass rate: %d%% (%d/%d)", passRate, ExecutorTest.Results.Pass, total))
    print(string.format("Duration: %.2fs", duration))
    print(string.format("Pass: %d | Fail: %d | Unknown: %d",
        ExecutorTest.Results.Pass, ExecutorTest.Results.Fail, ExecutorTest.Results.Unknown))

    if ExecutorTest.Config.ExportResults then
        exportResults()
    end
end

function exportResults()
    local payload = {
        Version = ExecutorTest.Version,
        Executor = identifyexecutor and identifyexecutor() or "Unknown",
        Timestamp = os.date("%Y-%m-%d %H:%M:%S"),
        Duration = now() - ExecutorTest.Results.StartTime,
        Results = {
            Pass = ExecutorTest.Results.Pass,
            Fail = ExecutorTest.Results.Fail,
            Unknown = ExecutorTest.Results.Unknown,
            Total = ExecutorTest.Results.Total,
        },
        BlockedFunctions = ExecutorTest.BlockedFunctions,
    }

    local json
    local ok, svc = pcall(function() return game:GetService("HttpService") end)
    if ok and svc and type(svc.JSONEncode) == "function" then
        local encOk, enc = pcall(function() return svc:JSONEncode(payload) end)
        if encOk then json = enc end
    end

    if not json then
        -- Minimal manual JSON fallback (no escaping for exotic chars)
        json = "{"
        json = json .. '"Version":"' .. safeToString(payload.Version) .. '",'
        json = json .. '"Executor":"' .. safeToString(payload.Executor) .. '",'
        json = json .. '"Timestamp":"' .. safeToString(payload.Timestamp) .. '",'
        json = json .. '"Duration":' .. string.format("%.2f", payload.Duration) .. ","
        json = json .. '"Results":{"Pass":' .. payload.Results.Pass .. ',"Fail":' .. payload.Results.Fail .. ',"Unknown":' .. payload.Results.Unknown .. ',"Total":' .. payload.Results.Total .. "}"
        json = json .. "}"
    end

    print("")
    print("Export JSON:")
    print(json)
end

-- Start
runTests()
