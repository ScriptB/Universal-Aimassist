--[[
	Phantom Suite  v2.0
	by Asuneteric

	Precision aimbot and ESP for competitive advantage.

	Features:
	  - Aimbot with smoothing, prediction, sticky aim, wall/team/health checks
	  - ESP with box, names, health bar, distance, tracers, head dot
	  - Full real-time Bracket UI controls
]]

local Bracket = loadstring(game:HttpGet("https://raw.githubusercontent.com/AlexR32/Bracket/main/BracketV32.lua"))()
Bracket:Notification({Title = "Phantom Suite", Description = "Precision aimbot and ESP  â€”  by Asuneteric", Duration = 5})
Bracket:Notification2({Title = "Phantom Suite"})

local RunService = game:GetService("RunService")
local players    = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local plr        = players.LocalPlayer
local camera     = workspace.CurrentCamera
local mouse      = plr:GetMouse()

--> [< Aimbot Variables >] <--

local hue = 0
local rainbowFov = false
local rainbowSpeed = 0.005

local aimFov = 100
local aiming = false
local predictionStrength = 0.065
local smoothing = 0.05

local aimbotEnabled = false
local wallCheck = true
local stickyAimEnabled = false
local teamCheck = false
local healthCheck = false
local minHealth = 0

local aimbotIncludeNPCs = false
local espIncludeNPCs = false
local npcScanInterval = 1
local npcMaxTargets = 60
local npcLastScan = 0
local npcTargets = {}

local circleColor = Color3.fromRGB(255, 0, 0)
local targetedCircleColor = Color3.fromRGB(0, 255, 0)

--> [< ESP Variables >] <--

local espEnabled   = false
local espBox       = true
local espNames     = true
local espHealth    = true
local espDistance  = true
local espTracers   = false
local espHeadDot   = false
local espTeamCheck = false
local espVisCheck  = false
local espMaxDist   = 1000
local espTextSize  = 13
local espBoxColor    = Color3.fromRGB(255, 0, 0)
local espNameColor   = Color3.fromRGB(255, 255, 255)
local espTracerColor = Color3.fromRGB(255, 255, 0)
local espTeamColor   = Color3.fromRGB(0, 162, 255)

local ESPData = {}
local QUAD_SUPPORTED = pcall(function() Drawing.new("Quad"):Remove() end)

--> [< UI Window >] <--

local Window = Bracket:Window({
    Name = "â–¶ Universal Aimbot + ESP â—€",
    Enabled = true,
    Color = Color3.fromRGB(100, 150, 255),
    Size = UDim2.new(0, 500, 0, 500),
    Position = UDim2.new(0.5, -250, 0.5, -250)
})

local uiVisible = true
local function setUIVisible(state)
	uiVisible = state
	pcall(function() Window.Enabled = state end)
	local function scan(parent)
		for _, v in ipairs(parent:GetChildren()) do
			if v:IsA("ScreenGui") and v.Name:lower():find("bracket") then
				v.Enabled = state
			end
		end
	end
	pcall(function() scan(game:GetService("CoreGui")) end)
	pcall(function() scan(plr:WaitForChild("PlayerGui")) end)
end

local Aimbot = Window:Tab({Name = "Aimbot ðŸŽ¯"})
local ESP    = Window:Tab({Name = "ESP ðŸ‘"})
local Admin  = Window:Tab({Name = "Admin ðŸ‘‘"})
local Keybinds  = Window:Tab({Name = "Keybinds âŒ¨"})

--> [< FOV Circle >] <--

local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 2
fovCircle.Radius = aimFov
fovCircle.Filled = false
fovCircle.Visible = false
fovCircle.Color = Color3.fromRGB(255, 0, 0)

local showFovCircle = true
local aimFovStep = 10

--> [< Aimbot Logic >] <--

local currentTarget = nil

local function getRootPart(character)
	return character and (character:FindFirstChild("HumanoidRootPart")
		or character:FindFirstChild("UpperTorso")
		or character:FindFirstChild("Torso")
		or character:FindFirstChild("LowerTorso"))
end

local function getAimPart(character)
	return character and (character:FindFirstChild("Head") or getRootPart(character))
end

local function resolveCharacter(target)
	if typeof(target) == "Instance" then
		if target:IsA("Player") then
			return target.Character, target
		end
		if target:IsA("Model") then
			return target, players:GetPlayerFromCharacter(target)
		end
	end
	if type(target) == "table" then
		local char = target.Character
		if typeof(char) == "Instance" and char:IsA("Model") then
			return char, players:GetPlayerFromCharacter(char)
		end
	end
	return nil, nil
end

local function checkTeam(target)
	if not teamCheck then return false end
	local _, p = resolveCharacter(target)
	return p ~= nil and p.Team == plr.Team
end

local function checkWall(targetCharacter)
    if not targetCharacter then return false end
    local targetPart = getAimPart(targetCharacter)
    if not targetPart then return false end

    local origin = camera.CFrame.Position
	local direction = targetPart.Position - origin
	if direction.Magnitude <= 0 then return false end

    local ignore = {targetCharacter, workspace.CurrentCamera}
    if plr.Character then table.insert(ignore, plr.Character) end

    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = ignore
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.IgnoreWater = true
    raycastParams.RespectCanCollide = true

	for _ = 1, 2 do
		local raycastResult = workspace:Raycast(origin, direction, raycastParams)
		if not raycastResult then
			return false
		end
		local hit = raycastResult.Instance
		if hit and hit:IsA("BasePart") and (hit.Transparency >= 0.95 or hit.CanCollide == false) then
			table.insert(ignore, hit)
			raycastParams.FilterDescendantsInstances = ignore
		else
			return true
		end
	end

	return false
end

local createESP, removeESP

local function ensureNPCScan()
	if not (aimbotIncludeNPCs or espIncludeNPCs) then
		if next(npcTargets) then
			for model in pairs(npcTargets) do
				npcTargets[model] = nil
				removeESP(model)
			end
		end
		return
	end
	local now = os.clock()
	if now - npcLastScan < npcScanInterval then return end
	npcLastScan = now

	local found = {}
	local count = 0
	local inspected = 0
	local maxInspect = 6000
	local roots = {}
	for _, name in ipairs({"NPCs","Bots","Mobs","Enemies","Enemy","AI"}) do
		local inst = workspace:FindFirstChild(name)
		if inst then
			roots[#roots + 1] = inst
		end
	end
	if #roots == 0 then
		roots[1] = workspace
	end

	for _, root in ipairs(roots) do
		for _, hum in ipairs(root:GetDescendants()) do
			inspected += 1
			if inspected >= maxInspect then break end
			if hum:IsA("Humanoid") and hum.Health > 0 then
				local model = hum.Parent
				while model and not model:IsA("Model") do
					model = model.Parent
				end
				if model and model:IsA("Model") and model ~= plr.Character and players:GetPlayerFromCharacter(model) == nil then
					local part = getAimPart(model)
					local rootPart = getRootPart(model)
					if part and rootPart then
						found[model] = true
						count += 1
						if count >= npcMaxTargets then
							break
						end
					end
				end
			end
		end
		if count >= npcMaxTargets or inspected >= maxInspect then
			break
		end
	end

	for model in pairs(npcTargets) do
		if not found[model] then
			npcTargets[model] = nil
			removeESP(model)
		end
	end
	for model in pairs(found) do
		npcTargets[model] = true
		if espIncludeNPCs and ESPData[model] == nil then
			createESP(model)
		end
	end
end

local function getTarget()
	ensureNPCScan()
    local nearestPlayer = nil
    local shortestCursorDistance = aimFov
    local shortestPlayerDistance = math.huge
    local cameraPos = camera.CFrame.Position
    for _, player in ipairs(players:GetPlayers()) do
        local character = player.Character
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        local aimPart = getAimPart(character)
        if player ~= plr and character and humanoid and humanoid.Health > 0 and aimPart and not checkTeam(character) then
            if humanoid.Health >= minHealth or not healthCheck then
                local headPos = camera:WorldToViewportPoint(aimPart.Position)
                local screenPos = Vector2.new(headPos.X, headPos.Y)
                local mousePos = Vector2.new(mouse.X, mouse.Y)
                local cursorDistance = (screenPos - mousePos).Magnitude
                local playerDistance = (aimPart.Position - cameraPos).Magnitude
                if cursorDistance < shortestCursorDistance and headPos.Z > 0 then
                    if (not wallCheck) or (not checkWall(character)) then
                        if playerDistance < shortestPlayerDistance then
                            shortestPlayerDistance = playerDistance
                            shortestCursorDistance = cursorDistance
                            nearestPlayer = player
                        end
                    end
                end
            end
        end
    end

	if aimbotIncludeNPCs then
		for model in pairs(npcTargets) do
			local character = model
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			local aimPart = getAimPart(character)
			if humanoid and humanoid.Health > 0 and aimPart then
				if humanoid.Health >= minHealth or not healthCheck then
					local headPos = camera:WorldToViewportPoint(aimPart.Position)
					local screenPos = Vector2.new(headPos.X, headPos.Y)
					local mousePos = Vector2.new(mouse.X, mouse.Y)
					local cursorDistance = (screenPos - mousePos).Magnitude
					local playerDistance = (aimPart.Position - cameraPos).Magnitude
					if cursorDistance < shortestCursorDistance and headPos.Z > 0 then
						if (not wallCheck) or (not checkWall(character)) then
							if playerDistance < shortestPlayerDistance then
								shortestPlayerDistance = playerDistance
								shortestCursorDistance = cursorDistance
								nearestPlayer = {Character = character}
							end
						end
					end
				end
			end
		end
	end
    return nearestPlayer
end

local function predict(player)
    if player and player.Character then
        local aimPart = getAimPart(player.Character)
        local hrp = getRootPart(player.Character)
        if not aimPart or not hrp then return nil end
        local velocity = hrp.Velocity
        local predictedPosition = aimPart.Position + (velocity * predictionStrength)
        return predictedPosition
    end
    return nil
end

local function smooth(from, to)
    return from:Lerp(to, smoothing)
end

local function aimAt(player)
    local predictedPosition = predict(player)
    if predictedPosition then
        local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid and humanoid.Health > 0 and (humanoid.Health >= minHealth or not healthCheck) then
            local targetCFrame = CFrame.new(camera.CFrame.Position, predictedPosition)
            camera.CFrame = smooth(camera.CFrame, targetCFrame)
        end
    end
end

--> [< ESP Logic >] <--

local function newDrawing(dtype, props)
    local d = Drawing.new(dtype)
    for k, v in pairs(props) do
        pcall(function() d[k] = v end)
    end
    return d
end

local function espIsTeammate(target)
    if not espTeamCheck then return false end
	local _, p = resolveCharacter(target)
	return p ~= nil and p.Team == plr.Team
end

local function espCheckWall(character)
    if not espVisCheck then return true end
    local part = getAimPart(character)
    if not part then return false end
    local origin = camera.CFrame.Position
    local dir = part.Position - origin
    local params = RaycastParams.new()
    local ignore = {character, workspace.CurrentCamera}
    if plr.Character then table.insert(ignore, plr.Character) end
    params.FilterDescendantsInstances = ignore
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.IgnoreWater = true
    params.RespectCanCollide = true

	for _ = 1, 2 do
		local result = workspace:Raycast(origin, dir, params)
		if not result then
			return true
		end
		local hit = result.Instance
		if hit and hit:IsA("BasePart") and (hit.Transparency >= 0.95 or hit.CanCollide == false) then
			table.insert(ignore, hit)
			params.FilterDescendantsInstances = ignore
		else
			return false
		end
	end

	return true
end

local function getHealthColor(h, max)
    local r = math.clamp(h / max, 0, 1)
    return Color3.fromRGB(math.floor((1 - r) * 255), math.floor(r * 255), 0)
end

createESP = function(target)
    local obj = {}
    if QUAD_SUPPORTED then
        obj.box        = newDrawing("Quad", {Visible=false, Color=espBoxColor, Thickness=1, Filled=false})
        obj.boxOutline = newDrawing("Quad", {Visible=false, Color=Color3.fromRGB(0,0,0), Thickness=3, Filled=false})
    else
        obj.boxT = newDrawing("Line", {Visible=false, Color=espBoxColor, Thickness=1})
        obj.boxB = newDrawing("Line", {Visible=false, Color=espBoxColor, Thickness=1})
        obj.boxL = newDrawing("Line", {Visible=false, Color=espBoxColor, Thickness=1})
        obj.boxR = newDrawing("Line", {Visible=false, Color=espBoxColor, Thickness=1})
    end
    obj.name        = newDrawing("Text",   {Visible=false, Text="", Size=espTextSize, Color=espNameColor, Center=true, Outline=true, OutlineColor=Color3.fromRGB(0,0,0)})
    obj.dist        = newDrawing("Text",   {Visible=false, Text="", Size=espTextSize-1, Color=Color3.fromRGB(200,200,200), Center=true, Outline=true, OutlineColor=Color3.fromRGB(0,0,0)})
    obj.healthBG    = newDrawing("Line",   {Visible=false, Color=Color3.fromRGB(0,0,0), Thickness=4})
    obj.health      = newDrawing("Line",   {Visible=false, Color=Color3.fromRGB(0,255,0), Thickness=2})
    obj.tracerOut   = newDrawing("Line",   {Visible=false, Color=Color3.fromRGB(0,0,0), Thickness=3})
    obj.tracer      = newDrawing("Line",   {Visible=false, Color=espTracerColor, Thickness=1})
    obj.headDot     = newDrawing("Circle", {Visible=false, Filled=true, NumSides=20, Radius=4, Color=espBoxColor})
    ESPData[target] = obj
end

removeESP = function(target)
    local obj = ESPData[target]
    if not obj then return end
    for _, d in pairs(obj) do pcall(function() d.Visible=false d:Remove() end) end
    ESPData[target] = nil
end

local function hideESPObj(obj)
    for _, d in pairs(obj) do pcall(function() d.Visible = false end) end
end

local function setBoxVis(obj, vis, color)
    if QUAD_SUPPORTED then
        obj.box.Visible = vis
        obj.boxOutline.Visible = vis
        if color and vis then obj.box.Color = color end
    else
        for _, k in ipairs({"boxT","boxB","boxL","boxR"}) do
            obj[k].Visible = vis
            if color and vis then obj[k].Color = color end
        end
    end
end

local function drawBox(obj, tl, tr, bl, br, color)
    if QUAD_SUPPORTED then
        obj.boxOutline.PointA=tl obj.boxOutline.PointB=tr obj.boxOutline.PointC=br obj.boxOutline.PointD=bl obj.boxOutline.Visible=true
        obj.box.PointA=tl obj.box.PointB=tr obj.box.PointC=br obj.box.PointD=bl obj.box.Color=color obj.box.Visible=true
    else
        obj.boxT.From=tl obj.boxT.To=tr obj.boxT.Color=color obj.boxT.Visible=true
        obj.boxB.From=bl obj.boxB.To=br obj.boxB.Color=color obj.boxB.Visible=true
        obj.boxL.From=tl obj.boxL.To=bl obj.boxL.Color=color obj.boxL.Visible=true
        obj.boxR.From=tr obj.boxR.To=br obj.boxR.Color=color obj.boxR.Visible=true
    end
end

local function updateESP(player, obj)
    local character, p = resolveCharacter(player)
    if not character then hideESPObj(obj) return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local hrp = getRootPart(character)
    local head = character:FindFirstChild("Head")
    local aimPart = getAimPart(character)
    if not humanoid or not hrp or not aimPart or humanoid.Health <= 0 then hideESPObj(obj) return end
    local dist = (hrp.Position - camera.CFrame.Position).Magnitude
    if dist > espMaxDist then hideESPObj(obj) return end
    if espVisCheck and not espCheckWall(character) then hideESPObj(obj) return end
    local headScreen = camera:WorldToViewportPoint(aimPart.Position)
    if headScreen.Z < 0 then hideESPObj(obj) return end

    local color = espIsTeammate(player) and espTeamColor or espBoxColor
    local scale = (head and head.Size.Y or 2) / 2
    local hrpCF = hrp.CFrame
    pcall(function() hrpCF = hrp:GetRenderCFrame() end)
    local headSizeY = head and head.Size.Y or 2
    local topPos = camera:WorldToViewportPoint((hrpCF * CFrame.new(0, headSizeY + hrp.Size.Y + 0.1, 0)).Position)
    local botPos = camera:WorldToViewportPoint((hrpCF * CFrame.new(0, -hrp.Size.Y, 0)).Position)
    if topPos.Z <= 0 or botPos.Z <= 0 then hideESPObj(obj) return end
    local height = math.abs(topPos.Y - botPos.Y)
    if height ~= height or height <= 1 or height > (camera.ViewportSize.Y * 5) then hideESPObj(obj) return end
    local width  = height * 0.55
    local cx     = headScreen.X
    local top    = topPos.Y
    local bot    = botPos.Y
    local left   = cx - width / 2
    local right  = cx + width / 2

    -- Box
    if espBox then
        drawBox(obj, Vector2.new(left,top), Vector2.new(right,top), Vector2.new(left,bot), Vector2.new(right,bot), color)
    else
        setBoxVis(obj, false)
    end

    -- Name
    if espNames then
        local name = character.Name
        if p then
            name = p.DisplayName
        end
        obj.name.Text = name
        obj.name.Position = Vector2.new(cx, top - 16)
        obj.name.Color = espNameColor
        obj.name.Size = espTextSize
        obj.name.Visible = true
    else
        obj.name.Visible = false
    end

    -- Distance
    if espDistance then
        obj.dist.Text = string.format("[%dm]", math.floor(dist))
        obj.dist.Position = Vector2.new(cx, top - (espNames and 28 or 16))
        obj.dist.Size = espTextSize - 1
        obj.dist.Visible = true
    else
        obj.dist.Visible = false
    end

    -- Health bar
    if espHealth then
        local ratio = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
        local barX = left - 5
        obj.healthBG.From = Vector2.new(barX, top) obj.healthBG.To = Vector2.new(barX, bot) obj.healthBG.Visible = true
        obj.health.From = Vector2.new(barX, bot) obj.health.To = Vector2.new(barX, bot - (bot - top) * ratio)
        obj.health.Color = getHealthColor(humanoid.Health, humanoid.MaxHealth) obj.health.Visible = true
    else
        obj.healthBG.Visible = false obj.health.Visible = false
    end

    -- Tracers
    if espTracers then
        local origin = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
        local target = Vector2.new(cx, bot)
        obj.tracerOut.From=origin obj.tracerOut.To=target obj.tracerOut.Visible=true
        obj.tracer.From=origin obj.tracer.To=target obj.tracer.Color=espIsTeammate(player) and espTeamColor or espTracerColor obj.tracer.Visible=true
    else
        obj.tracerOut.Visible=false obj.tracer.Visible=false
    end

    -- Head dot
    if espHeadDot then
        local dotPart = head or aimPart
        local topH = camera:WorldToViewportPoint((dotPart.CFrame * CFrame.new(0, scale, 0)).Position)
        local botH = camera:WorldToViewportPoint((dotPart.CFrame * CFrame.new(0, -scale, 0)).Position)
        obj.headDot.Radius = math.abs((Vector2.new(topH.X,topH.Y) - Vector2.new(botH.X,botH.Y)).Magnitude)
        obj.headDot.Position = Vector2.new(headScreen.X, headScreen.Y)
        obj.headDot.Color = color obj.headDot.Visible = true
    else
        obj.headDot.Visible = false
    end
end

--> [< Player Management >] <--

local function onPlayerAdded(player)
    if player == plr then return end
    createESP(player)
end

local function onPlayerRemoving(player)
    removeESP(player)
end

for _, player in ipairs(players:GetPlayers()) do onPlayerAdded(player) end
players.PlayerAdded:Connect(onPlayerAdded)
players.PlayerRemoving:Connect(onPlayerRemoving)

--> [< Render Loop >] <--

RunService.RenderStepped:Connect(function()
    ensureNPCScan()
    -- FOV circle
    fovCircle.Position = Vector2.new(mouse.X, mouse.Y + 50)
    if rainbowFov then
        hue = hue + rainbowSpeed
        if hue > 1 then hue = 0 end
        fovCircle.Color = Color3.fromHSV(hue, 1, 1)
    else
        fovCircle.Color = (aiming and currentTarget) and targetedCircleColor or circleColor
    end

    -- Aimbot
    if aimbotEnabled then
        if aiming then
            if stickyAimEnabled and currentTarget then
                local character = currentTarget.Character
                local aimPart = character and getAimPart(character)
                if not character or not aimPart then
                    currentTarget = nil
                else
                    local headPos = camera:WorldToViewportPoint(aimPart.Position)
                    local screenPos = Vector2.new(headPos.X, headPos.Y)
                    local cursorDistance = (screenPos - Vector2.new(mouse.X, mouse.Y)).Magnitude
                    if cursorDistance > aimFov or (wallCheck and checkWall(character)) or checkTeam(currentTarget) then
                        currentTarget = nil
                    end
                end
            end
            if not stickyAimEnabled or not currentTarget then
                currentTarget = getTarget()
            end
            if currentTarget then aimAt(currentTarget) end
        else
            currentTarget = nil
        end
    end

    -- ESP
    if not espEnabled then
        for _, obj in pairs(ESPData) do hideESPObj(obj) end
    else
        for player, obj in pairs(ESPData) do
            local ok = pcall(updateESP, player, obj)
            if not ok then
                hideESPObj(obj)
            end
        end
    end
end)

--> [< Aimbot UI >] <--

Aimbot:Divider({Text = "Main", Side = "Left"})

local aimbotToggle = Aimbot:Toggle({
    Name = "Aimbot", Side = "Left", Value = false,
    Callback = function(Value)
        aimbotEnabled = Value
        fovCircle.Visible = Value and showFovCircle
		if not Value then
			aiming = false
			currentTarget = nil
		end
    end
})

Aimbot:Divider({Text = "Settings", Side = "Left"})

Aimbot:Slider({
    Name = "Smoothing", Side = "Left", Min = 0, Max = 100, Value = 5, Precise = 0, Unit = "",
    Callback = function(Value) smoothing = 1 - (Value / 100) end
})

Aimbot:Slider({
    Name = "Prediction Strength", Side = "Left", Min = 0, Max = 200, Value = 65, Precise = 0, Unit = "",
    Callback = function(Value) predictionStrength = Value / 1000 end
})

local aimFovSlider = Aimbot:Slider({
    Name = "Aimbot Fov", Side = "Left", Min = 0, Max = 1000, Value = 100, Precise = 0, Unit = "",
    Callback = function(Value)
        aimFov = Value
        fovCircle.Radius = aimFov
    end
})

Aimbot:Divider({Text = "Filters", Side = "Left"})

local wallCheckToggle = Aimbot:Toggle({
    Name = "Wall Check", Side = "Left", Value = true,
    Callback = function(Value) wallCheck = Value end
})

Aimbot:Toggle({
	Name = "Include NPCs/Bots", Side = "Left", Value = false,
	Callback = function(Value) aimbotIncludeNPCs = Value end
})

Aimbot:Toggle({
    Name = "Sticky Aim", Side = "Left", Value = false,
    Callback = function(Value) stickyAimEnabled = Value end
})

Aimbot:Toggle({
    Name = "Team Check (Experimental)", Side = "Left", Value = false,
    Callback = function(Value) teamCheck = Value end
})

Aimbot:Toggle({
    Name = "Health Check (Experimental)", Side = "Left", Value = false,
    Callback = function(Value) healthCheck = Value end
})

Aimbot:Slider({
    Name = "Min Health", Side = "Left", Min = 0, Max = 100, Value = 0, Precise = 0, Unit = "",
    Callback = function(Value) minHealth = Value end
})

Aimbot:Divider({Text = "Visual", Side = "Left"})

Aimbot:Colorpicker({
    Name = "Fov Color", Color = circleColor,
    Callback = function(Table, Color)
        circleColor = Color
        if not rainbowFov then fovCircle.Color = Color end
    end
})

Aimbot:Colorpicker({
    Name = "Targeted Fov Color", Color = targetedCircleColor,
    Callback = function(Table, Color)
        targetedCircleColor = Color
    end
})

Aimbot:Toggle({
    Name = "Rainbow Fov", Side = "Left", Value = false,
    Callback = function(Value) rainbowFov = Value end
})

--> [< ESP UI >] <--

ESP:Divider({Text = "Main", Side = "Left"})

local espToggle = ESP:Toggle({
    Name = "ESP", Side = "Left", Value = false,
    Callback = function(Value) espEnabled = Value end
})

ESP:Divider({Text = "Features", Side = "Left"})

ESP:Toggle({
    Name = "Box", Side = "Left", Value = true,
    Callback = function(Value) espBox = Value end
})

ESP:Toggle({
    Name = "Names", Side = "Left", Value = true,
    Callback = function(Value) espNames = Value end
})

ESP:Toggle({
    Name = "Health Bar", Side = "Left", Value = true,
    Callback = function(Value) espHealth = Value end
})

ESP:Toggle({
    Name = "Distance", Side = "Left", Value = true,
    Callback = function(Value) espDistance = Value end
})

ESP:Toggle({
    Name = "Tracers", Side = "Left", Value = false,
    Callback = function(Value) espTracers = Value end
})

ESP:Toggle({
    Name = "Head Dot", Side = "Left", Value = false,
    Callback = function(Value) espHeadDot = Value end
})

ESP:Divider({Text = "Filters", Side = "Left"})

ESP:Toggle({
    Name = "Team Check", Side = "Left", Value = false,
    Callback = function(Value) espTeamCheck = Value end
})

ESP:Toggle({
    Name = "Visibility Check", Side = "Left", Value = false,
    Callback = function(Value) espVisCheck = Value end
})

ESP:Divider({Text = "Targets", Side = "Left"})

ESP:Toggle({
	Name = "Include NPCs/Bots", Side = "Left", Value = false,
	Callback = function(Value) espIncludeNPCs = Value end
})

ESP:Slider({
	Name = "NPC Scan Interval", Side = "Left", Min = 0.2, Max = 5, Value = 1, Precise = 1, Unit = "s",
	Callback = function(Value) npcScanInterval = Value end
})

ESP:Slider({
	Name = "Max NPC Targets", Side = "Left", Min = 1, Max = 200, Value = 60, Precise = 0, Unit = "",
	Callback = function(Value) npcMaxTargets = Value end
})

ESP:Slider({
    Name = "Max Distance", Side = "Left", Min = 100, Max = 5000, Value = 1000, Precise = 0, Unit = "",
    Callback = function(Value) espMaxDist = Value end
})

ESP:Slider({
    Name = "Text Size", Side = "Left", Min = 8, Max = 24, Value = 13, Precise = 0, Unit = "",
    Callback = function(Value) espTextSize = Value end
})

ESP:Divider({Text = "Colors", Side = "Left"})

ESP:Colorpicker({
    Name = "Box Color", Color = espBoxColor,
    Callback = function(Table, Color)
        espBoxColor = Color
    end
})

ESP:Colorpicker({
    Name = "Name Color", Color = espNameColor,
    Callback = function(Table, Color)
        espNameColor = Color
    end
})

ESP:Colorpicker({
    Name = "Tracer Color", Color = espTracerColor,
    Callback = function(Table, Color)
        espTracerColor = Color
    end
})

ESP:Colorpicker({
    Name = "Team Color", Color = espTeamColor,
    Callback = function(Table, Color)
        espTeamColor = Color
    end
})

Keybinds:Divider({Text = "Menu", Side = "Left"})

Keybinds:Keybind({
	Name = "Toggle GUI", Side = "Left", Value = "RightControl", Mouse = false,
	Blacklist = {"W","A","S","D","Slash","Tab","Backspace","Escape","Space","Delete","Unknown","Backquote"},
	Callback = function(_, pressed)
		if pressed then
			if UserInputService:GetFocusedTextBox() then return end
			setUIVisible(not uiVisible)
		end
	end
})

Keybinds:Divider({Text = "Aimbot Activation", Side = "Left"})

Keybinds:Keybind({
	Name = "Aimbot Hold", Side = "Left", Value = "MouseButton2", Mouse = true,
	Blacklist = {"W","A","S","D","Slash","Tab","Backspace","Escape","Space","Delete","Unknown","Backquote"},
	Callback = function(_, pressed)
		if UserInputService:GetFocusedTextBox() then return end
		if not aimbotEnabled then
			aiming = false
			return
		end
		aiming = pressed and true or false
	end
})

Keybinds:Divider({Text = "Toggles", Side = "Left"})

Keybinds:Keybind({
	Name = "Toggle Aimbot", Side = "Left", Value = "NONE", Mouse = false,
	Blacklist = {"W","A","S","D","Slash","Tab","Backspace","Escape","Space","Delete","Unknown","Backquote"},
	Callback = function(_, pressed)
		if pressed and aimbotToggle then
			if UserInputService:GetFocusedTextBox() then return end
			aimbotToggle:SetValue(not aimbotEnabled)
		end
	end
})

Keybinds:Keybind({
	Name = "Toggle ESP", Side = "Left", Value = "NONE", Mouse = false,
	Blacklist = {"W","A","S","D","Slash","Tab","Backspace","Escape","Space","Delete","Unknown","Backquote"},
	Callback = function(_, pressed)
		if pressed and espToggle then
			if UserInputService:GetFocusedTextBox() then return end
			espToggle:SetValue(not espEnabled)
		end
	end
})

Keybinds:Keybind({
	Name = "Toggle Wall Check", Side = "Left", Value = "NONE", Mouse = false,
	Blacklist = {"W","A","S","D","Slash","Tab","Backspace","Escape","Space","Delete","Unknown","Backquote"},
	Callback = function(_, pressed)
		if pressed and wallCheckToggle then
			if UserInputService:GetFocusedTextBox() then return end
			wallCheckToggle:SetValue(not wallCheck)
		end
	end
})

Keybinds:Keybind({
	Name = "Toggle FOV Circle", Side = "Left", Value = "NONE", Mouse = false,
	Blacklist = {"W","A","S","D","Slash","Tab","Backspace","Escape","Space","Delete","Unknown","Backquote"},
	Callback = function(_, pressed)
		if pressed then
			if UserInputService:GetFocusedTextBox() then return end
			showFovCircle = not showFovCircle
			fovCircle.Visible = aimbotEnabled and showFovCircle
		end
	end
})

Keybinds:Divider({Text = "FOV", Side = "Left"})

Keybinds:Slider({
	Name = "FOV Step", Side = "Left", Min = 1, Max = 100, Value = 10, Precise = 0, Unit = "",
	Callback = function(Value) aimFovStep = Value end
})

Keybinds:Keybind({
	Name = "FOV +", Side = "Left", Value = "NONE", Mouse = false,
	Blacklist = {"W","A","S","D","Slash","Tab","Backspace","Escape","Space","Delete","Unknown","Backquote"},
	Callback = function(_, pressed)
		if not pressed then return end
		if UserInputService:GetFocusedTextBox() then return end
		local newValue = math.clamp(aimFov + aimFovStep, 0, 1000)
		if aimFovSlider then
			aimFovSlider:SetValue(newValue)
		else
			aimFov = newValue
			fovCircle.Radius = aimFov
		end
	end
})

Keybinds:Keybind({
	Name = "FOV -", Side = "Left", Value = "NONE", Mouse = false,
	Blacklist = {"W","A","S","D","Slash","Tab","Backspace","Escape","Space","Delete","Unknown","Backquote"},
	Callback = function(_, pressed)
		if not pressed then return end
		if UserInputService:GetFocusedTextBox() then return end
		local newValue = math.clamp(aimFov - aimFovStep, 0, 1000)
		if aimFovSlider then
			aimFovSlider:SetValue(newValue)
		else
			aimFov = newValue
			fovCircle.Radius = aimFov
		end
	end
})

Keybinds:Divider({Text = "Safety", Side = "Left"})

Keybinds:Keybind({
	Name = "Panic (Disable All + Hide GUI)", Side = "Left", Value = "NONE", Mouse = false,
	Blacklist = {"W","A","S","D","Slash","Tab","Backspace","Escape","Space","Delete","Unknown","Backquote"},
	Callback = function(_, pressed)
		if not pressed then return end
		if UserInputService:GetFocusedTextBox() then return end
		aiming = false
		currentTarget = nil
		if aimbotToggle then aimbotToggle:SetValue(false) end
		if espToggle then espToggle:SetValue(false) end
		showFovCircle = false
		fovCircle.Visible = false
		setUIVisible(false)
	end
})

--> [< Admin Tab >] <--

Admin:Divider({Text = "Admin Tools", Side = "Left"})

Admin:Button({
    Name = "Load Infinite Yield", Side = "Left",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/ScriptB/Infinite-Yield/refs/heads/main/Infinite%20Yield_fixed2.lua"))()
    end
})
