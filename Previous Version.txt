--[[
	Phantom Suite  v3.3 (Anti-Missfire Protection)
	by Asuneteric

	Precision aimbot and ESP for competitive advantage.

	Features:
	  - Aimbot with smoothing, prediction, sticky aim, wall/team/health checks
	  - ESP with box, names, health bar, distance, tracers, head dot
	  - Full real-time Bracket UI controls
	  - HWID-keyed config auto-save/load (Phantom-Config.txt)
]]

local RunService = game:GetService("RunService")
local players    = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local plr        = players.LocalPlayer
local camera     = workspace.CurrentCamera
local mouse      = plr:GetMouse()

--> [< Aimbot Variables >] <--

local hue = 0
local rainbowFov = false
local rainbowSpeed = 0.005

local aimFov = 100
local aiming = false
local predictionStrength = 0.065
local smoothing = 0.05

-- Trigger bot variables
local lastTriggerTime = 0
local triggerInterval = 0.1 -- Shoot every 0.1 seconds when locked
local triggerTarget = nil

-- ESP/Aimbot distance lock variables
local espLockDistance = 500
local aimbotLockDistance = 500

local aimbotEnabled = false
local blatantEnabled = false
local triggerBotEnabled = false

-- UI toggle references (assigned when UI is built)
local triggerBotToggle = nil
local rainbowFovToggle = nil
local espTeamCheckToggle = nil
local espToggle = nil
local wallCheck = true
local stickyAimEnabled = false
local teamCheck = false
local healthCheck = false
local minHealth = 0

-- Targeting mode (from provided code)
local targetMode = "Closest To Mouse" -- Options: "Closest To Mouse", "Distance"

local aimbotIncludeNPCs = false
local espIncludeNPCs = false
local npcScanInterval = 1
local npcMaxTargets = 60
local npcLastScan = 0
local npcTargets = {}

local circleColor = Color3.fromRGB(255, 0, 0)
local targetedCircleColor = Color3.fromRGB(0, 255, 0)

--> [< ESP Variables >] <--

local espEnabled   = false
local espBox       = true
local espNames     = true
local espHealth    = true
local espDistance  = true
local espTracers   = false
local espHeadDot   = false
local espTeamCheck = false
local espVisCheck  = false
local espMaxDist   = 1000
local espTextSize  = 13
local espBoxColor    = Color3.fromRGB(255, 0, 0)
local espNameColor   = Color3.fromRGB(255, 255, 255)
local espTracerColor = Color3.fromRGB(255, 255, 0)
local espTeamColor   = Color3.fromRGB(0, 162, 255)

--> [< Extras / Commands Variables >] <--

local flyEnabled       = false
local noclipEnabled    = false
local infJumpEnabled   = false
local flySpeed         = 50
local walkSpeed        = 16
local jumpPower        = 50

local extrasConnections = {
    noclip   = nil,
    infJump  = nil,
    fly      = nil,
}

--> [< HWID + Config System >] <--

local CONFIG_FILE = "Phantom-Config.txt"
local HWID_FILE   = "Phantom-HWID.txt"

local function getHWID()
	local id
	if typeof(gethwid) == "function" then
		pcall(function() id = tostring(gethwid()) end)
		if id and #id > 4 then return id end
	end
	if typeof(syn) == "table" and typeof(syn.request) == "function" then
		pcall(function()
			local r = syn.request({Url="https://httpbin.org/get",Method="GET"})
			if r and r.Headers and r.Headers["X-Amzn-Trace-Id"] then
				id = r.Headers["X-Amzn-Trace-Id"]
			end
		end)
		if id and #id > 4 then return id end
	end
	if typeof(isfile) == "function" and typeof(readfile) == "function" and typeof(writefile) == "function" then
		if isfile(HWID_FILE) then
			pcall(function() id = readfile(HWID_FILE) end)
			if id and #id > 4 then return id end
		end
		local seed = tostring(os.time()) .. tostring(math.random(100000,999999)) .. tostring(plr.UserId)
		pcall(function() writefile(HWID_FILE, seed) end)
		return seed
	end
	return tostring(plr.UserId)
end

local HWID = getHWID()

local function configToTable()
	return {
		hwid              = HWID,
		aimbotEnabled     = aimbotEnabled,
		blatantEnabled     = blatantEnabled,
		triggerBotEnabled  = triggerBotEnabled,
		wallCheck         = wallCheck,
		stickyAimEnabled  = stickyAimEnabled,
		teamCheck         = teamCheck,
		healthCheck       = healthCheck,
		minHealth         = minHealth,
		aimFov            = aimFov,
		predictionStrength= predictionStrength * 1000,
		smoothing         = math.floor((1 - smoothing) * 8 + 2.5),
		aimbotLockDistance= aimbotLockDistance,
		rainbowFov        = rainbowFov,
		rainbowSpeed      = rainbowSpeed,
		aimbotIncludeNPCs = aimbotIncludeNPCs,
		espEnabled        = espEnabled,
		espBox            = espBox,
		espNames          = espNames,
		espHealth         = espHealth,
		espDistance       = espDistance,
		espTracers        = espTracers,
		espHeadDot        = espHeadDot,
		espTeamCheck      = espTeamCheck,
		espVisCheck       = espVisCheck,
		espMaxDist        = espMaxDist,
		espLockDistance   = espLockDistance,
		espTextSize       = espTextSize,
		espIncludeNPCs    = espIncludeNPCs,
		npcScanInterval   = npcScanInterval,
		npcMaxTargets     = npcMaxTargets,
		espBoxColorR      = math.floor(espBoxColor.R * 255),
		espBoxColorG      = math.floor(espBoxColor.G * 255),
		espBoxColorB      = math.floor(espBoxColor.B * 255),
		espNameColorR     = math.floor(espNameColor.R * 255),
		espNameColorG     = math.floor(espNameColor.G * 255),
		espNameColorB     = math.floor(espNameColor.B * 255),
		espTracerColorR   = math.floor(espTracerColor.R * 255),
		espTracerColorG   = math.floor(espTracerColor.G * 255),
		espTracerColorB   = math.floor(espTracerColor.B * 255),
		circleColorR      = math.floor(circleColor.R * 255),
		circleColorG      = math.floor(circleColor.G * 255),
		circleColorB      = math.floor(circleColor.B * 255),
		flySpeed          = flySpeed,
		walkSpeed         = walkSpeed,
		jumpPower         = jumpPower,
	}
end

local function saveConfig()
	if typeof(writefile) ~= "function" then return false end
	local data = {}
	if typeof(isfile) == "function" and isfile(CONFIG_FILE) then
		pcall(function()
			data = HttpService:JSONDecode(readfile(CONFIG_FILE))
		end)
		if type(data) ~= "table" then data = {} end
	end
	data[HWID] = configToTable()
	local ok = pcall(function()
		writefile(CONFIG_FILE, HttpService:JSONEncode(data))
	end)
	return ok
end

local loadedConfig = nil
local function loadConfig()
	if typeof(isfile) ~= "function" or typeof(readfile) ~= "function" then return nil end
	if not isfile(CONFIG_FILE) then return nil end
	local data
	local ok = pcall(function()
		data = HttpService:JSONDecode(readfile(CONFIG_FILE))
	end)
	if not ok or type(data) ~= "table" then return nil end
	local cfg = data[HWID]
	if type(cfg) ~= "table" then return nil end
	return cfg
end

local function applyConfig(cfg)
	if not cfg then return end
	if type(cfg.aimbotEnabled)      == "boolean" then aimbotEnabled     = cfg.aimbotEnabled     end
	if type(cfg.blatantEnabled)      == "boolean" then blatantEnabled     = cfg.blatantEnabled     end
	if type(cfg.triggerBotEnabled)   == "boolean" then triggerBotEnabled  = cfg.triggerBotEnabled  end
	if type(cfg.wallCheck)          == "boolean" then wallCheck         = cfg.wallCheck         end
	if type(cfg.stickyAimEnabled)   == "boolean" then stickyAimEnabled  = cfg.stickyAimEnabled  end
	if type(cfg.teamCheck)          == "boolean" then teamCheck         = cfg.teamCheck         end
	if type(cfg.healthCheck)        == "boolean" then healthCheck       = cfg.healthCheck       end
	if type(cfg.minHealth)          == "number"  then minHealth         = cfg.minHealth         end
	if type(cfg.aimFov)             == "number"  then aimFov            = cfg.aimFov            end
	if type(cfg.predictionStrength) == "number"  then predictionStrength= cfg.predictionStrength / 1000 end
	if type(cfg.smoothing)          == "number"  then smoothing         = 1 - (cfg.smoothing / 10) end
	if type(cfg.aimbotLockDistance) == "number"  then aimbotLockDistance= cfg.aimbotLockDistance end
	if type(cfg.rainbowFov)         == "boolean" then rainbowFov        = cfg.rainbowFov        end
	if type(cfg.rainbowSpeed)       == "number"  then rainbowSpeed      = cfg.rainbowSpeed      end
	if type(cfg.aimbotIncludeNPCs)  == "boolean" then aimbotIncludeNPCs = cfg.aimbotIncludeNPCs end
	if type(cfg.espEnabled)         == "boolean" then espEnabled        = cfg.espEnabled        end
	if type(cfg.espBox)             == "boolean" then espBox            = cfg.espBox            end
	if type(cfg.espNames)           == "boolean" then espNames          = cfg.espNames          end
	if type(cfg.espHealth)          == "boolean" then espHealth         = cfg.espHealth         end
	if type(cfg.espDistance)        == "boolean" then espDistance       = cfg.espDistance       end
	if type(cfg.espTracers)         == "boolean" then espTracers        = cfg.espTracers        end
	if type(cfg.espHeadDot)         == "boolean" then espHeadDot        = cfg.espHeadDot        end
	if type(cfg.espTeamCheck)       == "boolean" then espTeamCheck      = cfg.espTeamCheck      end
	if type(cfg.espVisCheck)        == "boolean" then espVisCheck       = cfg.espVisCheck       end
	if type(cfg.espMaxDist)         == "number"  then espMaxDist        = cfg.espMaxDist        end
	if type(cfg.espLockDistance)    == "number"  then espLockDistance   = cfg.espLockDistance   end
	if type(cfg.espTextSize)        == "number"  then espTextSize       = cfg.espTextSize       end
	if type(cfg.espIncludeNPCs)     == "boolean" then espIncludeNPCs    = cfg.espIncludeNPCs    end
	if type(cfg.npcScanInterval)    == "number"  then npcScanInterval   = cfg.npcScanInterval   end
	if type(cfg.npcMaxTargets)      == "number"  then npcMaxTargets     = cfg.npcMaxTargets     end
	if type(cfg.espBoxColorR)       == "number"  then
		espBoxColor = Color3.fromRGB(cfg.espBoxColorR, cfg.espBoxColorG or 0, cfg.espBoxColorB or 0)
	end
	if type(cfg.espNameColorR)      == "number"  then
		espNameColor = Color3.fromRGB(cfg.espNameColorR, cfg.espNameColorG or 255, cfg.espNameColorB or 255)
	end
	if type(cfg.espTracerColorR)    == "number"  then
		espTracerColor = Color3.fromRGB(cfg.espTracerColorR, cfg.espTracerColorG or 255, cfg.espTracerColorB or 0)
	end
	if type(cfg.circleColorR)       == "number"  then
		circleColor = Color3.fromRGB(cfg.circleColorR, cfg.circleColorG or 0, cfg.circleColorB or 0)
	end
	if type(cfg.flySpeed)           == "number"  then flySpeed   = cfg.flySpeed   end
	if type(cfg.walkSpeed)          == "number"  then walkSpeed  = cfg.walkSpeed  end
	if type(cfg.jumpPower)          == "number"  then jumpPower  = cfg.jumpPower  end
end

loadedConfig = loadConfig()
applyConfig(loadedConfig)

local Bracket = loadstring(game:HttpGet("https://raw.githubusercontent.com/AlexR32/Bracket/main/BracketV32.lua"))()
Bracket:Notification({Title = "Phantom Suite", Description = "Precision aimbot and ESP  â€”  by Asuneteric", Duration = 5})
Bracket:Notification2({Title = "Phantom Suite"})

local ESPData = {}
local QUAD_SUPPORTED = pcall(function() Drawing.new("Quad"):Remove() end)
local ESPDrawings = {}
local espWasEnabled = false

--> [< UI Window >] <--

local Window = Bracket:Window({
    Name = "â–¶ Universal Aimbot + ESP â—€",
    Enabled = true,
    Color = Color3.fromRGB(100, 150, 255),
    Size = UDim2.new(0, 500, 0, 500),
    Position = UDim2.new(0.5, -250, 0.5, -250)
})

local uiVisible = true
local uiDestroyed = false
local fovCircle

local function hideAllESPDrawingObjects()
	for d in pairs(ESPDrawings) do
		local ok = pcall(function() d.Visible = false end)
		if not ok then
			ESPDrawings[d] = nil
		end
	end
end

local function destroyUI()
	uiDestroyed = true
	uiVisible = false
	pcall(function() Window.Enabled = false end)
	pcall(function() fovCircle.Visible = false end)
	pcall(function() hideAllESPDrawingObjects() end)
	pcall(function()
		local gui = Bracket and Bracket.ScreenAsset
		if typeof(gui) == "Instance" then
			gui:Destroy()
		end
	end)
	pcall(function()
		for _, parent in ipairs({game:GetService("CoreGui"), plr:FindFirstChildOfClass("PlayerGui")}) do
			if parent then
				for _, v in ipairs(parent:GetDescendants()) do
					if v:IsA("ScreenGui") and v.Name:lower():find("bracket") then
						v:Destroy()
					end
				end
			end
		end
	end)
end

local function setUIVisible(state)
	if uiDestroyed then return end
	uiVisible = state
	pcall(function() Window.Enabled = state end)
	local function scan(parent)
		for _, v in ipairs(parent:GetDescendants()) do
			if v:IsA("ScreenGui") and v.Name:lower():find("bracket") then
				v.Enabled = state
			end
		end
	end
	pcall(function() scan(game:GetService("CoreGui")) end)
	pcall(function() scan(plr:WaitForChild("PlayerGui")) end)
	pcall(function()
		local gui = Bracket and Bracket.ScreenAsset
		if typeof(gui) == "Instance" then
			gui.Enabled = state
		end
	end)
end

local Aimbot   = Window:Tab({Name = "Aimbot ðŸŽ¯"})
local ESP      = Window:Tab({Name = "ESP ðŸ‘"})
local Extras   = Window:Tab({Name = "Extras âš¡"})
local Admin    = Window:Tab({Name = "Admin ðŸ‘‘"})
local Keybinds = Window:Tab({Name = "Keybinds âŒ¨"})
local Info     = Window:Tab({Name = "Info â„¹"})

Info:Divider({Text = "Phantom Suite Information", Side = "Left"})
Info:Label({Text = "Welcome to Phantom Suite v2.3!", Side = "Left"})
Info:Label({Text = "Precision aimbot and ESP by Asuneteric", Side = "Left"})
Info:Label({Text = "", Side = "Left"})

Info:Divider({Text = "âš ï¸ Important Notice", Side = "Left"})
Info:Label({Text = "If features aren't working or loading,", Side = "Left"})
Info:Label({Text = "this is due to your executor's limitations.", Side = "Left"})
Info:Label({Text = "Some executors lack require functions", Side = "Left"})
Info:Label({Text = "and other essential capabilities.", Side = "Left"})
Info:Label({Text = "", Side = "Left"})
Info:Label({Text = "This cannot be fixed on our end.", Side = "Left"})
Info:Label({Text = "Please use a compatible executor.", Side = "Left"})
Info:Label({Text = "", Side = "Left"})

Info:Divider({Text = "ðŸ”§ Recommended Executors", Side = "Left"})
Info:Label({Text = "â€¢ Synapse X (Premium)", Side = "Left"})
Info:Label({Text = "â€¢ ScriptWare (Premium)", Side = "Left"})
Info:Label({Text = "â€¢ KRNL (Free)", Side = "Left"})
Info:Label({Text = "â€¢ Fluxus (Free)", Side = "Left"})
Info:Label({Text = "", Side = "Left"})

Info:Divider({Text = "ðŸ› Troubleshooting", Side = "Left"})
Info:Label({Text = "â€¢ Re-execute the script", Side = "Left"})
Info:Label({Text = "â€¢ Check executor updates", Side = "Left"})
Info:Label({Text = "â€¢ Try a different executor", Side = "Left"})
Info:Label({Text = "â€¢ Ensure game is supported", Side = "Left"})
Info:Label({Text = "â€¢ Disable other scripts", Side = "Left"})
Info:Label({Text = "", Side = "Left"})

Info:Divider({Text = "ðŸ“‹ Features", Side = "Left"})
Info:Label({Text = "â€¢ Advanced Aimbot System", Side = "Left"})
Info:Label({Text = "â€¢ Full ESP Customization", Side = "Left"})
Info:Label({Text = "â€¢ HWID Config System", Side = "Left"})
Info:Label({Text = "â€¢ Real-time UI Controls", Side = "Left"})
Info:Label({Text = "", Side = "Left"})

Info:Divider({Text = "ðŸ’¬ Support", Side = "Left"})
Info:Label({Text = "For support, join our Discord", Side = "Left"})
Info:Label({Text = "or check the documentation.", Side = "Left"})

--> [< FOV Circle >] <--

fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 2
fovCircle.Radius = aimFov
fovCircle.Filled = false
fovCircle.Visible = false
fovCircle.Color = Color3.fromRGB(255, 0, 0)

local showFovCircle = true
local aimFovStep = 10

--> [< Aimbot Logic >] <--

local currentTarget = nil

local function getRootPart(character)
	return character and (character:FindFirstChild("HumanoidRootPart")
		or character:FindFirstChild("UpperTorso")
		or character:FindFirstChild("Torso")
		or character:FindFirstChild("LowerTorso"))
end

local function getAimPart(character)
	return character and (character:FindFirstChild("Head") or getRootPart(character))
end

local function resolveCharacter(target)
	if typeof(target) == "Instance" then
		if target:IsA("Player") then
			return target.Character, target
		end
		if target:IsA("Model") then
			return target, players:GetPlayerFromCharacter(target)
		end
	end
	if type(target) == "table" then
		local char = target.Character
		if typeof(char) == "Instance" and char:IsA("Model") then
			return char, players:GetPlayerFromCharacter(char)
		end
	end
	return nil, nil
end

--> [< Team Detection System >] <--

-- Team cache for performance and change detection
local teamCache = {}
local lastTeamCheck = 0
local teamCheckInterval = 0.5 -- Check for team changes every 0.5 seconds

-- Timing-safe team detection (DevForum loading issue fix)
local function isOnSameTeam(targetPlayer)
	if not targetPlayer then return false end
	if targetPlayer == plr then return true end
	
	-- Wait for teams to be loaded (DevForum timing fix)
	local myTeam = plr.Team
	local theirTeam = targetPlayer.Team
	
	-- If either team is nil, player might still be loading
	if not myTeam or not theirTeam then
		-- Check if players are still loading
		if not plr.Character or not targetPlayer.Character then
			return false -- Assume not teammates during loading
		end
		
		-- Fallback to TeamColor during loading
		local myTeamColor = plr.TeamColor
		local theirTeamColor = targetPlayer.TeamColor
		if myTeamColor and theirTeamColor then
			return myTeamColor == theirTeamColor
		end
		
		-- Handle neutral players during loading
		if plr.Neutral or targetPlayer.Neutral then
			return false
		end
		
		return false -- Default during loading
	end
	
	-- Method 1: Direct Team object comparison (most reliable)
	if myTeam and theirTeam then
		return myTeam == theirTeam
	end
	
	-- Method 2: TeamColor comparison (official fallback)
	local myTeamColor = plr.TeamColor
	local theirTeamColor = targetPlayer.TeamColor
	if myTeamColor and theirTeamColor then
		return myTeamColor == theirTeamColor
	end
	
	-- Method 3: Check Neutral property (players without teams)
	if plr.Neutral or targetPlayer.Neutral then
		return false
	end
	
	-- Method 4: Team name comparison (last resort)
	if myTeam and theirTeam then
		return myTeam.Name == theirTeam.Name
	end
	
	-- Default: assume not teammates if all methods fail
	return false
end

-- Periodic team change detection system
local function detectTeamChanges()
	local currentTime = tick()
	if currentTime - lastTeamCheck < teamCheckInterval then return end
	lastTeamCheck = currentTime
	
	-- Check all players for team changes
	for _, player in ipairs(players:GetPlayers()) do
		if player ~= plr then
			local currentTeam = player.Team
			local currentTeamColor = player.TeamColor
			local currentNeutral = player.Neutral
			local cacheKey = tostring(player.UserId)
			
			local cached = teamCache[cacheKey]
			if not cached then
				-- First time seeing this player
				teamCache[cacheKey] = {
					Team = currentTeam,
					TeamColor = currentTeamColor,
					Neutral = currentNeutral,
					lastUpdate = currentTime
				}
			elseif cached.Team ~= currentTeam or cached.TeamColor ~= currentTeamColor or cached.Neutral ~= currentNeutral then
				-- Team changed! Update cache
				teamCache[cacheKey] = {
					Team = currentTeam,
					TeamColor = currentTeamColor,
					Neutral = currentNeutral,
					lastUpdate = currentTime
				}
				-- Clear ESP for this player to force refresh
				if ESPData[player] then
					removeESP(player)
					createESP(player)
				end
			end
		end
	end
	
	-- Clean up cache for players who left
	for cacheKey, cached in pairs(teamCache) do
		if currentTime - cached.lastUpdate > 5 then -- 5 seconds timeout
			teamCache[cacheKey] = nil
		end
	end
end

-- Enhanced team validation with DevForum-proven methods
local function validateTeamRelationship(player1, player2)
	if not player1 or not player2 then return false end
	if player1 == player2 then return true end
	
	-- Method 1: Direct Team object comparison (most reliable)
	local team1 = player1.Team
	local team2 = player2.Team
	if team1 and team2 then
		return team1 == team2
	end
	
	-- Method 2: TeamColor comparison with BrickColor (DevForum proven)
	local color1 = player1.TeamColor
	local color2 = player2.TeamColor
	if color1 and color2 then
		return color1 == color2
	end
	
	-- Method 3: Teams service comparison (most precise)
	local teamsService = game:GetService("Teams")
	if team1 and team2 then
		-- Check if both teams exist in Teams service
		for _, team in pairs(teamsService:GetTeams()) do
			if team == team1 and team == team2 then
				return true
			end
		end
	end
	
	-- Method 4: Handle neutral players (DevForum confirmed)
	if player1.Neutral or player2.Neutral then
		return false
	end
	
	-- Method 5: BrickColor comparison (DevForum suggestion)
	if color1 and color2 then
		local brickColor1 = color1
		local brickColor2 = color2
		return brickColor1 == brickColor2
	end
	
	return false
end

--> [< Separate ESP Targeting Functions >] <--

-- ESP-only closest player to mouse detection (no aimbot interference)
local function getESPClosestPlayerToMouse()
	local closestPlayer = nil
	local closestDistance = math.huge
	local cameraPos = camera.CFrame.Position
	
	for _, player in ipairs(players:GetPlayers()) do
		if player ~= plr and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			local hrp = player.Character.HumanoidRootPart
			local screenPoint = camera:WorldToViewportPoint(hrp.Position)
			local mousePoint = Vector2.new(mouse.X, mouse.Y)
			local distance = (mousePoint - Vector2.new(screenPoint.X, screenPoint.Y)).Magnitude
			local _, onScreen = camera:WorldToViewportPoint(hrp.Position)
			
			-- Apply ESP distance lock
			local playerDistance = (hrp.Position - cameraPos).Magnitude
			if playerDistance > espLockDistance then continue end
			
			if onScreen and distance < closestDistance then
				closestPlayer = player
				closestDistance = distance
			end
		end
	end
	
	return closestPlayer
end

-- ESP-only closest by distance detection (no aimbot interference)
local function getESPClosestByDistance()
	local closestPlayer = nil
	local closestDistance = math.huge
	local cameraPos = camera.CFrame.Position
	
	for _, player in ipairs(players:GetPlayers()) do
		if player ~= plr and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			local hrp = player.Character.HumanoidRootPart
			local distance = (hrp.Position - cameraPos).Magnitude
			
			-- Apply ESP distance lock
			if distance > espLockDistance then continue end
			
			if distance < closestDistance then
				closestPlayer = player
				closestDistance = distance
			end
		end
	end
	
	return closestPlayer
end

--> [< Aimbot-Only Targeting Functions >] <--

-- Aimbot-only closest player to mouse detection (from provided code)
local function getClosestPlayerToMouse()
	local closestPlayer = nil
	local closestDistance = math.huge
	local cameraPos = camera.CFrame.Position
	
	for _, player in ipairs(players:GetPlayers()) do
		if player ~= plr and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			-- Apply team check if enabled
			if teamCheck and isOnSameTeam(player) then continue end
			
			local hrp = player.Character.HumanoidRootPart
			local screenPoint = camera:WorldToViewportPoint(hrp.Position)
			local mousePoint = Vector2.new(mouse.X, mouse.Y)
			local distance = (mousePoint - Vector2.new(screenPoint.X, screenPoint.Y)).Magnitude
			local _, onScreen = camera:WorldToViewportPoint(hrp.Position)
			
			-- Apply aimbot distance lock
			local playerDistance = (hrp.Position - cameraPos).Magnitude
			if playerDistance > aimbotLockDistance then continue end
			
			if onScreen and distance < closestDistance then
				closestPlayer = player
				closestDistance = distance
			end
		end
	end
	
	return closestPlayer
end

-- Aimbot-only closest by distance detection (from provided code)
local function getClosestByDistance()
	local closestPlayer = nil
	local closestDistance = math.huge
	local cameraPos = camera.CFrame.Position
	
	for _, player in ipairs(players:GetPlayers()) do
		if player ~= plr and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			-- Apply team check if enabled
			if teamCheck and isOnSameTeam(player) then continue end
			
			local hrp = player.Character.HumanoidRootPart
			local distance = (hrp.Position - cameraPos).Magnitude
			
			-- Apply aimbot distance lock
			if distance > aimbotLockDistance then continue end
			
			if distance < closestDistance then
				closestPlayer = player
				closestDistance = distance
			end
		end
	end
	
	return closestPlayer
end

local function checkTeam(target)
	if not teamCheck and not blatantEnabled then return false end
	local _, targetPlayer = resolveCharacter(target)
	return isOnSameTeam(targetPlayer)
end

local function checkWall(targetCharacter)
    if not targetCharacter then return false end
    local targetPart = getAimPart(targetCharacter)
    if not targetPart then return false end

    local origin = camera.CFrame.Position
	local direction = targetPart.Position - origin
	if direction.Magnitude <= 0 then return false end

    local ignore = {targetCharacter, workspace.CurrentCamera}
    if plr.Character then table.insert(ignore, plr.Character) end

    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = ignore
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.IgnoreWater = true
    raycastParams.RespectCanCollide = true

	for _ = 1, 2 do
		local raycastResult = workspace:Raycast(origin, direction, raycastParams)
		if not raycastResult then
			return false
		end
		local hit = raycastResult.Instance
		if hit and hit:IsA("BasePart") and (hit.Transparency >= 0.95 or hit.CanCollide == false) then
			table.insert(ignore, hit)
			raycastParams.FilterDescendantsInstances = ignore
		else
			return true
		end
	end

	return false
end

local createESP, removeESP

local function ensureNPCScan()
	if not (aimbotIncludeNPCs or espIncludeNPCs) then
		if next(npcTargets) then
			for model in pairs(npcTargets) do
				npcTargets[model] = nil
				removeESP(model)
			end
		end
		return
	end
	local now = os.clock()
	if now - npcLastScan < npcScanInterval then return end
	npcLastScan = now

	local found = {}
	local count = 0
	local inspected = 0
	local maxInspect = 6000
	local roots = {}
	for _, name in ipairs({"NPCs","Bots","Mobs","Enemies","Enemy","AI"}) do
		local inst = workspace:FindFirstChild(name)
		if inst then
			roots[#roots + 1] = inst
		end
	end
	if #roots == 0 then
		roots[1] = workspace
	end

	for _, root in ipairs(roots) do
		for _, hum in ipairs(root:GetDescendants()) do
			inspected += 1
			if inspected >= maxInspect then break end
			if hum:IsA("Humanoid") and hum.Health > 0 then
				local model = hum.Parent
				while model and not model:IsA("Model") do
					model = model.Parent
				end
				if model and model:IsA("Model") and model ~= plr.Character and players:GetPlayerFromCharacter(model) == nil then
					local part = getAimPart(model)
					local rootPart = getRootPart(model)
					if part and rootPart then
						found[model] = true
						count += 1
						if count >= npcMaxTargets then
							break
						end
					end
				end
			end
		end
		if count >= npcMaxTargets or inspected >= maxInspect then
			break
		end
	end

	for model in pairs(npcTargets) do
		if not found[model] then
			npcTargets[model] = nil
			removeESP(model)
		end
	end
	for model in pairs(found) do
		npcTargets[model] = true
		if espIncludeNPCs and ESPData[model] == nil then
			createESP(model)
		end
	end
end

local function getTarget()
	ensureNPCScan()
	
	-- Use improved targeting methods based on mode
	local nearestPlayer = nil
	if targetMode == "Closest To Mouse" then
		nearestPlayer = getClosestPlayerToMouse()
	elseif targetMode == "Distance" then
		nearestPlayer = getClosestByDistance()
	end
	
	-- Apply additional checks (health, wall, etc.)
	if nearestPlayer and nearestPlayer.Character then
		local humanoid = nearestPlayer.Character:FindFirstChildOfClass("Humanoid")
		if not humanoid or humanoid.Health <= 0 then return nil end
		if healthCheck and humanoid.Health < minHealth then return nil end
		if wallCheck and checkWall(nearestPlayer.Character) then return nil end
	end
	
	-- Handle NPCs if enabled
	if aimbotIncludeNPCs and nearestPlayer then
		local nearestNPC = nil
		local closestNPCDistance = math.huge
		local cameraPos = camera.CFrame.Position
		
		for model in pairs(npcTargets) do
			local humanoid = model:FindFirstChildOfClass("Humanoid")
			local aimPart = getAimPart(model)
			if humanoid and humanoid.Health > 0 and aimPart then
				if healthCheck and humanoid.Health < minHealth then continue end
				
				local distance = (aimPart.Position - cameraPos).Magnitude
				if distance > aimbotLockDistance then continue end
				if wallCheck and checkWall(model) then continue end
				
				if distance < closestNPCDistance then
					closestNPCDistance = distance
					nearestNPC = {Character = model}
				end
			end
		end
		
		-- Compare NPC distance with player distance
		if nearestNPC then
			local playerDistance = nearestPlayer.Character and 
				(getAimPart(nearestPlayer.Character).Position - cameraPos).Magnitude or math.huge
			
			if closestNPCDistance < playerDistance then
				return nearestNPC
			end
		end
	end
	
	return nearestPlayer
end

-- Clean blatant target: closest visible enemy, ignoring FOV, always wall-checked
local function getBlatantTarget()
	ensureNPCScan()
	local best = nil
	local bestDist = math.huge
	local camPos = camera.CFrame.Position

	for _, player in ipairs(players:GetPlayers()) do
		if player == plr then continue end
		local char = player.Character
		if not char then continue end
		local hum = char:FindFirstChildOfClass("Humanoid")
		if not hum or hum.Health <= 0 then continue end
		if checkTeam(char) then continue end
		local part = getAimPart(char)
		if not part then continue end
		local dist = (part.Position - camPos).Magnitude
		if dist > aimbotLockDistance then continue end
		if checkWall(char) then continue end -- must be visible
		if dist < bestDist then
			bestDist = dist
			best = player
		end
	end

	if aimbotIncludeNPCs then
		for model in pairs(npcTargets) do
			local hum = model:FindFirstChildOfClass("Humanoid")
			if not hum or hum.Health <= 0 then continue end
			local part = getAimPart(model)
			if not part then continue end
			local dist = (part.Position - camPos).Magnitude
			if dist > aimbotLockDistance then continue end
			if checkWall(model) then continue end
			if dist < bestDist then
				bestDist = dist
				best = {Character = model}
			end
		end
	end

	return best
end

local function fireWeapon()
    -- Method 1: Tool.Fire (most reliable for Roblox weapons)
    local tool = plr.Character:FindFirstChildOfClass("Tool") or plr.Character:FindFirstChildWhichIsA("Tool")
    if tool and tool:FindFirstChild("Fire") then
        tool:Fire()
        return true
    end
    
    -- Method 2: Context Action Service (for some games)
    local CAS = game:GetService("ContextActionService")
    CAS:CallAction("Fire")
    
    -- Method 3: Official Synapse X API (100% UNC optimized)
    if syn_mouse1press then
        syn_mouse1press()
        task.wait(0.05) -- Brief hold
        syn_mouse1release()
        return true
    end
    
    -- Method 4: Humanoid state method (last resort)
    if plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") then
        local humanoid = plr.Character.Humanoid
        if humanoid:GetStateEnabled(Enum.HumanoidStateType.Jumping) then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            task.wait()
            humanoid:ChangeState(Enum.HumanoidStateType.Landed)
            return true
        end
    end
    
    return false
end


local function triggerBotFire()
	if not (triggerBotEnabled or blatantEnabled) then return end
	
	-- Block firing when interacting with UI
	if UserInputService:GetFocusedTextBox() then return end
	local ml = UserInputService:GetMouseLocation()
	if #game:GetService("GuiService"):GetGuiObjectsAtPosition(ml.X, ml.Y) > 0 then return end

	-- Use mouse.Target for direct hit detection (from working example)
	if mouse.Target and mouse.Target.Parent:FindFirstChild("Humanoid") and mouse.Target.Parent.Name ~= plr.Name then
		local targetPlayer = players:GetPlayerFromCharacter(mouse.Target.Parent)
		
		if targetPlayer and targetPlayer.Team ~= plr.Team then
			if tick() - lastTriggerTime >= triggerInterval then
				-- Use official Synapse X API for 100% UNC
				syn_mouse1press()
				wait()
				syn_mouse1release()
				lastTriggerTime = tick()
			end
		end
	end
end


local function enableBlatantMode()
	blatantEnabled = true
	triggerBotEnabled = true
	rainbowFov = true
	
	-- Reset team cache when entering blatant mode
	teamCache = {}
	lastTeamCheck = 0
	
	-- Update UI toggles
	if triggerBotToggle then triggerBotToggle:SetValue(true) end
	if rainbowFovToggle then rainbowFovToggle:SetValue(true) end
end

local function disableBlatantMode()
	blatantEnabled = false
	currentTarget = nil
	triggerTarget = nil
	
	-- Only disable features that are part of blatant mode
	triggerBotEnabled = false
	rainbowFov = false
	
	-- Update UI toggles
	if triggerBotToggle then triggerBotToggle:SetValue(false) end
	if rainbowFovToggle then rainbowFovToggle:SetValue(false) end
end

local function predict(target)
    local char = (type(target) == "table" and target.Character) or (typeof(target) == "Instance" and target:IsA("Player") and target.Character) or nil
    if not char then return nil end
    local aimPart = getAimPart(char)
    local hrp = getRootPart(char)
    if not aimPart or not hrp then return nil end
    return aimPart.Position + (hrp.Velocity * predictionStrength)
end

local function smooth(from, to)
    return from:Lerp(to, smoothing)
end

local function aimAt(target)
    -- Validate target exists and is valid
    if not target then return end
    
    local char = (type(target) == "table" and target.Character) or (typeof(target) == "Instance" and target:IsA("Player") and target.Character) or nil
    if not char then return end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return end
    if healthCheck and humanoid.Health < minHealth then return end
    
    local aimPart = getAimPart(char)
    if not aimPart then return end
    
    -- Additional validation: ensure aimPart has valid position
    local targetPosition = aimPart.Position
    if not targetPosition or (targetPosition.X == 0 and targetPosition.Y == 0 and targetPosition.Z == 0) then return end
    
    -- Ensure target is within reasonable distance
    local distance = (targetPosition - camera.CFrame.Position).Magnitude
    if distance > aimbotLockDistance * 2 then return end -- Extra safety margin
    
    if blatantEnabled then
        -- Direct snap to head, no prediction (prediction causes left/right wobble)
        -- Only aim if target is visible and valid
        if not wallCheck or not checkWall(char) then
            camera.CFrame = CFrame.new(camera.CFrame.Position, targetPosition)
        end
    else
        local predictedPosition = predict(target)
        if not predictedPosition then return end
        -- Only aim if predicted position is valid and within range
        local predictedDistance = (predictedPosition - camera.CFrame.Position).Magnitude
        if predictedDistance <= aimbotLockDistance * 2 then
            camera.CFrame = smooth(camera.CFrame, CFrame.new(camera.CFrame.Position, predictedPosition))
        end
    end
end

--> [< ESP Logic >] <--

local function newDrawing(dtype, props)
    local d = Drawing.new(dtype)
	ESPDrawings[d] = true
    for k, v in pairs(props) do
        pcall(function() d[k] = v end)
    end
    return d
end

-- ESP-only team check (no aimbot interference)
local function espIsTeammate(target)
    -- Skip team check if ESP team check is disabled
    if not espTeamCheck then return false end
    
    local _, targetPlayer = resolveCharacter(target)
    -- NPCs (no player object) are never teammates
    if not targetPlayer then return false end
    
    -- Use enhanced team validation for maximum accuracy
    return validateTeamRelationship(plr, targetPlayer)
end

-- Aimbot-only team check (no ESP interference)
local function aimbotIsTeammate(target)
    -- Skip team check if aimbot team check is disabled
    if not teamCheck then return false end
    
    local _, targetPlayer = resolveCharacter(target)
    -- NPCs (no player object) are never teammates
    if not targetPlayer then return false end
    
    -- Use enhanced team validation for maximum accuracy
    return validateTeamRelationship(plr, targetPlayer)
end

local function espCheckWall(character)
    if not espVisCheck then return true end
    local part = getAimPart(character)
    if not part then return false end
    local origin = camera.CFrame.Position
    local dir = part.Position - origin
    local params = RaycastParams.new()
    local ignore = {character, workspace.CurrentCamera}
    if plr.Character then table.insert(ignore, plr.Character) end
    params.FilterDescendantsInstances = ignore
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.IgnoreWater = true
    params.RespectCanCollide = true

	for _ = 1, 2 do
		local result = workspace:Raycast(origin, dir, params)
		if not result then
			return true
		end
		local hit = result.Instance
		if hit and hit:IsA("BasePart") and (hit.Transparency >= 0.95 or hit.CanCollide == false) then
			table.insert(ignore, hit)
			params.FilterDescendantsInstances = ignore
		else
			return false
		end
	end

	return true
end

local function getHealthColor(h, max)
    local r = math.clamp(h / max, 0, 1)
    return Color3.fromRGB(math.floor((1 - r) * 255), math.floor(r * 255), 0)
end

createESP = function(target)
	if ESPData[target] then
		removeESP(target)
	end
    local obj = {}
    if QUAD_SUPPORTED then
        obj.box        = newDrawing("Quad", {Visible=false, Color=espBoxColor, Thickness=1, Filled=false})
        obj.boxOutline = newDrawing("Quad", {Visible=false, Color=Color3.fromRGB(0,0,0), Thickness=3, Filled=false})
    else
        obj.boxT = newDrawing("Line", {Visible=false, Color=espBoxColor, Thickness=1})
        obj.boxB = newDrawing("Line", {Visible=false, Color=espBoxColor, Thickness=1})
        obj.boxL = newDrawing("Line", {Visible=false, Color=espBoxColor, Thickness=1})
        obj.boxR = newDrawing("Line", {Visible=false, Color=espBoxColor, Thickness=1})
    end
    obj.name        = newDrawing("Text",   {Visible=false, Text="", Size=espTextSize, Color=espNameColor, Center=true, Outline=true, OutlineColor=Color3.fromRGB(0,0,0)})
    obj.dist        = newDrawing("Text",   {Visible=false, Text="", Size=espTextSize-1, Color=Color3.fromRGB(200,200,200), Center=true, Outline=true, OutlineColor=Color3.fromRGB(0,0,0)})
    obj.healthBG    = newDrawing("Line",   {Visible=false, Color=Color3.fromRGB(0,0,0), Thickness=4})
    obj.health      = newDrawing("Line",   {Visible=false, Color=Color3.fromRGB(0,255,0), Thickness=2})
    obj.tracerOut   = newDrawing("Line",   {Visible=false, Color=Color3.fromRGB(0,0,0), Thickness=3})
    obj.tracer      = newDrawing("Line",   {Visible=false, Color=espTracerColor, Thickness=1})
    obj.headDot     = newDrawing("Circle", {Visible=false, Filled=true, NumSides=20, Radius=4, Color=espBoxColor})
    ESPData[target] = obj
end

removeESP = function(target)
    local obj = ESPData[target]
    if not obj then return end
    for _, d in pairs(obj) do
		pcall(function() d.Visible=false d:Remove() end)
		ESPDrawings[d] = nil
	end
    ESPData[target] = nil
end

local function hideESPObj(obj)
    for _, d in pairs(obj) do pcall(function() d.Visible = false end) end
end

local function setBoxVis(obj, vis, color)
    if QUAD_SUPPORTED then
        obj.box.Visible = vis
        obj.boxOutline.Visible = vis
        if color and vis then obj.box.Color = color end
    else
        for _, k in ipairs({"boxT","boxB","boxL","boxR"}) do
            obj[k].Visible = vis
            if color and vis then obj[k].Color = color end
        end
    end
end

local function drawBox(obj, tl, tr, bl, br, color)
    if QUAD_SUPPORTED then
        obj.boxOutline.PointA=tl obj.boxOutline.PointB=tr obj.boxOutline.PointC=br obj.boxOutline.PointD=bl obj.boxOutline.Visible=true
        obj.box.PointA=tl obj.box.PointB=tr obj.box.PointC=br obj.box.PointD=bl obj.box.Color=color obj.box.Visible=true
    else
        obj.boxT.From=tl obj.boxT.To=tr obj.boxT.Color=color obj.boxT.Visible=true
        obj.boxB.From=bl obj.boxB.To=br obj.boxB.Color=color obj.boxB.Visible=true
        obj.boxL.From=tl obj.boxL.To=bl obj.boxL.Color=color obj.boxL.Visible=true
        obj.boxR.From=tr obj.boxR.To=br obj.boxR.Color=color obj.boxR.Visible=true
    end
end

local function updateESP(player, obj)
    local character, p = resolveCharacter(player)
    if not character then hideESPObj(obj) return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local hrp = getRootPart(character)
    local head = character:FindFirstChild("Head")
    local aimPart = getAimPart(character)
    if not humanoid or not hrp or not aimPart or humanoid.Health <= 0 then hideESPObj(obj) return end
    local dist = (hrp.Position - camera.CFrame.Position).Magnitude
    
    -- Apply ESP distance lock
    if dist > espLockDistance then 
        hideESPObj(obj) 
        return 
    end
    
    -- Apply max distance check
    if dist > espMaxDist then hideESPObj(obj) return end
    
    -- Apply visibility check if enabled
    if espVisCheck and not espCheckWall(character) then hideESPObj(obj) return end
    
    -- Hide teammates when team check is enabled (forced in blatant mode)
    local isTeammate = espIsTeammate(player)
    if isTeammate then 
        hideESPObj(obj) 
        return 
    end
    
    local headScreen = camera:WorldToViewportPoint(aimPart.Position)
    if headScreen.Z < 0 then hideESPObj(obj) return end

    local color = espBoxColor -- Only show enemy color
    local scale = (head and head.Size.Y or 2) / 2
    local hrpCF = hrp.CFrame
    pcall(function() hrpCF = hrp:GetRenderCFrame() end)
    local headSizeY = head and head.Size.Y or 2
    local topPos = camera:WorldToViewportPoint((hrpCF * CFrame.new(0, headSizeY + hrp.Size.Y + 0.1, 0)).Position)
    local botPos = camera:WorldToViewportPoint((hrpCF * CFrame.new(0, -hrp.Size.Y, 0)).Position)
    if topPos.Z <= 0 or botPos.Z <= 0 then hideESPObj(obj) return end
    local height = math.abs(topPos.Y - botPos.Y)
    if height ~= height or height <= 1 or height > (camera.ViewportSize.Y * 5) then hideESPObj(obj) return end
    local width  = height * 0.55
    local cx     = headScreen.X
    local top    = topPos.Y
    local bot    = botPos.Y
    local left   = cx - width / 2
    local right  = cx + width / 2

    -- Box
    if espBox then
        drawBox(obj, Vector2.new(left,top), Vector2.new(right,top), Vector2.new(left,bot), Vector2.new(right,bot), color)
    else
        setBoxVis(obj, false)
    end

    -- Name
    if espNames then
        local name = character.Name
        if p then
            name = p.DisplayName
        end
        obj.name.Text = name
        obj.name.Position = Vector2.new(cx, top - 16)
        obj.name.Color = espNameColor
        obj.name.Size = espTextSize
        obj.name.Visible = true
    else
        obj.name.Visible = false
    end

    -- Distance
    if espDistance then
        obj.dist.Text = string.format("[%dm]", math.floor(dist))
        obj.dist.Position = Vector2.new(cx, top - (espNames and 28 or 16))
        obj.dist.Size = espTextSize - 1
        obj.dist.Visible = true
    else
        obj.dist.Visible = false
    end

    -- Health bar
    if espHealth then
        local ratio = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
        local barX = left - 5
        obj.healthBG.From = Vector2.new(barX, top) obj.healthBG.To = Vector2.new(barX, bot) obj.healthBG.Visible = true
        obj.health.From = Vector2.new(barX, bot) obj.health.To = Vector2.new(barX, bot - (bot - top) * ratio)
        obj.health.Color = getHealthColor(humanoid.Health, humanoid.MaxHealth) obj.health.Visible = true
    else
        obj.healthBG.Visible = false obj.health.Visible = false
    end

    -- Tracers
    if espTracers then
        local origin = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
        local target = Vector2.new(cx, bot)
        obj.tracerOut.From=origin obj.tracerOut.To=target obj.tracerOut.Visible=true
        obj.tracer.From=origin obj.tracer.To=target obj.tracer.Color=espTracerColor obj.tracer.Visible=true
    else
        obj.tracerOut.Visible=false obj.tracer.Visible=false
    end

    -- Head dot
    if espHeadDot then
        local dotPart = head or aimPart
        local topH = camera:WorldToViewportPoint((dotPart.CFrame * CFrame.new(0, scale, 0)).Position)
        local botH = camera:WorldToViewportPoint((dotPart.CFrame * CFrame.new(0, -scale, 0)).Position)
        obj.headDot.Radius = math.abs((Vector2.new(topH.X,topH.Y) - Vector2.new(botH.X,botH.Y)).Magnitude)
        obj.headDot.Position = Vector2.new(headScreen.X, headScreen.Y)
        obj.headDot.Color = color obj.headDot.Visible = true
    else
        obj.headDot.Visible = false
    end
end

--> [< Player Management >] <--

local function onPlayerAdded(player)
    if player == plr then return end
    createESP(player)
end

local function onPlayerRemoving(player)
    removeESP(player)
end

for _, player in ipairs(players:GetPlayers()) do onPlayerAdded(player) end
players.PlayerAdded:Connect(onPlayerAdded)
players.PlayerRemoving:Connect(onPlayerRemoving)


RunService.RenderStepped:Connect(function()
	local ok = pcall(function()
		ensureNPCScan()
		
		-- Periodic team change detection (enhanced for blatant mode)
		if blatantEnabled then
			detectTeamChanges()
		end
		
		-- FOV circle
		fovCircle.Position = Vector2.new(mouse.X, mouse.Y + 50)
		if rainbowFov then
			hue = hue + rainbowSpeed
			if hue > 1 then hue = 0 end
			fovCircle.Color = Color3.fromHSV(hue, 1, 1)
		else
			fovCircle.Color = (aiming and currentTarget) and targetedCircleColor or circleColor
		end

		-- Aimbot System
		if aimbotEnabled or blatantEnabled then
			if blatantEnabled then
				-- Blatant: always active, snap to closest visible enemy
				currentTarget = getBlatantTarget()
				if currentTarget then
					aimAt(currentTarget)
				end
			elseif aiming then
				-- Normal aimbot requires aiming key
				if stickyAimEnabled and currentTarget then
					local character = currentTarget.Character
					if character and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0 then
						if not checkTeam(character) then
							if character.Humanoid.Health >= minHealth or not healthCheck then
								if not wallCheck or not checkWall(character) then
									aimAt(currentTarget)
								end
							end
						end
					else
						currentTarget = nil
					end
				end
				if not stickyAimEnabled or not currentTarget then
					currentTarget = getTarget()
				end
				if currentTarget then 
					aimAt(currentTarget)
				end
			else
				currentTarget = nil
			end
		end
		
		-- Trigger Bot
		if triggerBotEnabled or blatantEnabled then
			if aiming or blatantEnabled then
				triggerBotFire()
			end
		end

		-- ESP
		if not espEnabled then
			if espWasEnabled then
				hideAllESPDrawingObjects()
			end
			for _, obj in pairs(ESPData) do hideESPObj(obj) end
		else
			for target, obj in pairs(ESPData) do
				updateESP(target, obj)
			end
		end
		espWasEnabled = espEnabled
	end)
	if not ok then
		hideAllESPDrawingObjects()
		fovCircle.Visible = false
	end
end)

--> [< Aimbot UI >] <--

Aimbot:Divider({Text = "Main", Side = "Left"})

local aimbotToggle = Aimbot:Toggle({
    Name = "Aimbot", Side = "Left", Value = aimbotEnabled,
    Callback = function(Value)
        aimbotEnabled = Value
        fovCircle.Visible = Value and showFovCircle
		if not Value then
			aiming = false
			currentTarget = nil
		end
    end
})

local blatantToggle = Aimbot:Toggle({
    Name = "Blatant (Snap to Visible)", Side = "Left", Value = blatantEnabled,
    Callback = function(Value)
        if Value then
            enableBlatantMode()
        else
            disableBlatantMode()
        end
        fovCircle.Visible = (aimbotEnabled or blatantEnabled) and showFovCircle
    end
})

triggerBotToggle = Aimbot:Toggle({
    Name = "Trigger Bot", Side = "Left", Value = triggerBotEnabled,
    Callback = function(Value)
        if blatantEnabled and not Value then return end
        triggerBotEnabled = Value
        if not Value then triggerTarget = nil end
    end
})

Aimbot:Divider({Text = "Settings", Side = "Left"})

Aimbot:Slider({
    Name = "Smoothing", Side = "Left", Min = 2, Max = 10, Value = math.max(2, math.floor((1 - smoothing) * 8 + 2.5)), Precise = 0, Unit = "",
    Callback = function(Value) smoothing = 1 - (Value / 10) end
})

Aimbot:Slider({
    Name = "Distance Lock", Side = "Left", Min = 100, Max = 2000, Value = aimbotLockDistance, Precise = 0, Unit = "",
    Callback = function(Value) aimbotLockDistance = Value end
})

local aimFovSlider = Aimbot:Slider({
    Name = "Aimbot Fov", Side = "Left", Min = 0, Max = 1000, Value = aimFov, Precise = 0, Unit = "",
    Callback = function(Value)
        aimFov = Value
        fovCircle.Radius = aimFov
    end
})

Aimbot:Slider({
    Name = "Prediction Strength", Side = "Left", Min = 0, Max = 200, Value = math.floor(predictionStrength * 1000 + 0.5), Precise = 0, Unit = "",
    Callback = function(Value) predictionStrength = Value / 1000 end
})

Aimbot:Divider({Text = "Filters", Side = "Left"})

local wallCheckToggle = Aimbot:Toggle({
    Name = "Wall Check", Side = "Left", Value = wallCheck,
    Callback = function(Value) wallCheck = Value end
})

Aimbot:Toggle({
	Name = "Include NPCs/Bots", Side = "Left", Value = aimbotIncludeNPCs,
	Callback = function(Value) aimbotIncludeNPCs = Value end
})

Aimbot:Toggle({
    Name = "Sticky Aim", Side = "Left", Value = stickyAimEnabled,
    Callback = function(Value) stickyAimEnabled = Value end
})

Aimbot:Toggle({
    Name = "Team Check (Experimental)", Side = "Left", Value = teamCheck,
    Callback = function(Value) teamCheck = Value end
})

Aimbot:Toggle({
    Name = "Health Check (Experimental)", Side = "Left", Value = healthCheck,
    Callback = function(Value) healthCheck = Value end
})

Aimbot:Slider({
    Name = "Min Health", Side = "Left", Min = 0, Max = 100, Value = minHealth, Precise = 0, Unit = "",
    Callback = function(Value) minHealth = Value end
})

Aimbot:Divider({Text = "Visual", Side = "Left"})

Aimbot:Colorpicker({
    Name = "Fov Color", Color = circleColor,
    Callback = function(Table, Color)
        circleColor = Color
        if not rainbowFov then fovCircle.Color = Color end
    end
})

Aimbot:Colorpicker({
    Name = "Targeted Fov Color", Color = targetedCircleColor,
    Callback = function(Table, Color)
        targetedCircleColor = Color
    end
})

rainbowFovToggle = Aimbot:Toggle({
    Name = "Rainbow Fov", Side = "Left", Value = rainbowFov,
    Callback = function(Value) rainbowFov = Value end
})

--> [< ESP UI >] <--

ESP:Divider({Text = "Main", Side = "Left"})

espToggle = ESP:Toggle({
    Name = "ESP", Side = "Left", Value = espEnabled,
	Callback = function(Value)
		espEnabled = Value
		if not Value then
			espWasEnabled = false
			hideAllESPDrawingObjects()
			for _, obj in pairs(ESPData) do hideESPObj(obj) end
		end
	end
})

ESP:Divider({Text = "Features", Side = "Left"})

ESP:Toggle({
    Name = "Box", Side = "Left", Value = espBox,
    Callback = function(Value) espBox = Value end
})

ESP:Toggle({
    Name = "Names", Side = "Left", Value = espNames,
    Callback = function(Value) espNames = Value end
})

ESP:Toggle({
    Name = "Health Bar", Side = "Left", Value = espHealth,
    Callback = function(Value) espHealth = Value end
})

ESP:Toggle({
    Name = "Distance", Side = "Left", Value = espDistance,
    Callback = function(Value) espDistance = Value end
})

ESP:Toggle({
    Name = "Tracers", Side = "Left", Value = espTracers,
    Callback = function(Value) espTracers = Value end
})

ESP:Toggle({
    Name = "Head Dot", Side = "Left", Value = espHeadDot,
    Callback = function(Value) espHeadDot = Value end
})

ESP:Divider({Text = "Filters", Side = "Left"})

espTeamCheckToggle = ESP:Toggle({
    Name = "Team Check", Side = "Left", Value = espTeamCheck,
    Callback = function(Value) espTeamCheck = Value end
})

ESP:Toggle({
    Name = "Visibility Check", Side = "Left", Value = espVisCheck,
    Callback = function(Value) espVisCheck = Value end
})

ESP:Divider({Text = "Targets", Side = "Left"})

ESP:Toggle({
	Name = "Include NPCs/Bots", Side = "Left", Value = espIncludeNPCs,
	Callback = function(Value) espIncludeNPCs = Value end
})

ESP:Slider({
	Name = "NPC Scan Interval", Side = "Left", Min = 0.2, Max = 5, Value = npcScanInterval, Precise = 1, Unit = "s",
	Callback = function(Value) npcScanInterval = Value end
})

ESP:Slider({
	Name = "Max NPC Targets", Side = "Left", Min = 1, Max = 200, Value = npcMaxTargets, Precise = 0, Unit = "",
	Callback = function(Value) npcMaxTargets = Value end
})

ESP:Slider({
    Name = "Max Distance", Side = "Left", Min = 100, Max = 5000, Value = espMaxDist, Precise = 0, Unit = "",
    Callback = function(Value) espMaxDist = Value end
})

ESP:Slider({
    Name = "Distance Lock", Side = "Left", Min = 100, Max = 2000, Value = espLockDistance, Precise = 0, Unit = "",
    Callback = function(Value) espLockDistance = Value end
})

ESP:Slider({
    Name = "Text Size", Side = "Left", Min = 8, Max = 24, Value = espTextSize, Precise = 0, Unit = "",
    Callback = function(Value) espTextSize = Value end
})

ESP:Divider({Text = "Colors", Side = "Left"})

ESP:Colorpicker({
    Name = "Box Color", Color = espBoxColor,
    Callback = function(Table, Color)
        espBoxColor = Color
    end
})

ESP:Colorpicker({
    Name = "Name Color", Color = espNameColor,
    Callback = function(Table, Color)
        espNameColor = Color
    end
})

ESP:Colorpicker({
    Name = "Tracer Color", Color = espTracerColor,
    Callback = function(Table, Color)
        espTracerColor = Color
    end
})

ESP:Colorpicker({
    Name = "Team Color", Color = espTeamColor,
    Callback = function(Table, Color)
        espTeamColor = Color
    end
})

Keybinds:Divider({Text = "Menu", Side = "Left"})

Keybinds:Keybind({
	Name = "Toggle GUI", Side = "Left", Value = "RightControl", Mouse = false,
	Blacklist = {"W","A","S","D","Slash","Tab","Backspace","Escape","Space","Delete","Unknown","Backquote"},
	Callback = function(_, pressed)
		if pressed then
			if UserInputService:GetFocusedTextBox() then return end
			setUIVisible(not uiVisible)
		end
	end
})

Keybinds:Divider({Text = "Aimbot Activation", Side = "Left"})

Keybinds:Keybind({
	Name = "Aimbot Hold", Side = "Left", Value = "MouseButton2", Mouse = true,
	Blacklist = {"W","A","S","D","Slash","Tab","Backspace","Escape","Space","Delete","Unknown","Backquote"},
	Callback = function(_, pressed)
		if UserInputService:GetFocusedTextBox() then return end
		if not aimbotEnabled then
			aiming = false
			return
		end
		aiming = pressed and true or false
	end
})

Keybinds:Divider({Text = "Toggles", Side = "Left"})

Keybinds:Keybind({
	Name = "Toggle Aimbot", Side = "Left", Value = "NONE", Mouse = false,
	Blacklist = {"W","A","S","D","Slash","Tab","Backspace","Escape","Space","Delete","Unknown","Backquote"},
	Callback = function(_, pressed)
		if pressed and aimbotToggle then
			if UserInputService:GetFocusedTextBox() then return end
			aimbotToggle:SetValue(not aimbotEnabled)
		end
	end
})

Keybinds:Keybind({
	Name = "Toggle ESP", Side = "Left", Value = "NONE", Mouse = false,
	Blacklist = {"W","A","S","D","Slash","Tab","Backspace","Escape","Space","Delete","Unknown","Backquote"},
	Callback = function(_, pressed)
		if pressed and espToggle then
			if UserInputService:GetFocusedTextBox() then return end
			espToggle:SetValue(not espEnabled)
		end
	end
})

Keybinds:Keybind({
	Name = "Toggle Wall Check", Side = "Left", Value = "NONE", Mouse = false,
	Blacklist = {"W","A","S","D","Slash","Tab","Backspace","Escape","Space","Delete","Unknown","Backquote"},
	Callback = function(_, pressed)
		if pressed and wallCheckToggle then
			if UserInputService:GetFocusedTextBox() then return end
			wallCheckToggle:SetValue(not wallCheck)
		end
	end
})

Keybinds:Keybind({
	Name = "Toggle FOV Circle", Side = "Left", Value = "NONE", Mouse = false,
	Blacklist = {"W","A","S","D","Slash","Tab","Backspace","Escape","Space","Delete","Unknown","Backquote"},
	Callback = function(_, pressed)
		if pressed then
			if UserInputService:GetFocusedTextBox() then return end
			showFovCircle = not showFovCircle
			fovCircle.Visible = aimbotEnabled and showFovCircle
		end
	end
})

Keybinds:Divider({Text = "FOV", Side = "Left"})

Keybinds:Slider({
	Name = "FOV Step", Side = "Left", Min = 1, Max = 100, Value = 10, Precise = 0, Unit = "",
	Callback = function(Value) aimFovStep = Value end
})

Keybinds:Keybind({
	Name = "FOV +", Side = "Left", Value = "NONE", Mouse = false,
	Blacklist = {"W","A","S","D","Slash","Tab","Backspace","Escape","Space","Delete","Unknown","Backquote"},
	Callback = function(_, pressed)
		if not pressed then return end
		if UserInputService:GetFocusedTextBox() then return end
		local newValue = math.clamp(aimFov + aimFovStep, 0, 1000)
		if aimFovSlider then
			aimFovSlider:SetValue(newValue)
		else
			aimFov = newValue
			fovCircle.Radius = aimFov
		end
	end
})

Keybinds:Keybind({
	Name = "FOV -", Side = "Left", Value = "NONE", Mouse = false,
	Blacklist = {"W","A","S","D","Slash","Tab","Backspace","Escape","Space","Delete","Unknown","Backquote"},
	Callback = function(_, pressed)
		if not pressed then return end
		if UserInputService:GetFocusedTextBox() then return end
		local newValue = math.clamp(aimFov - aimFovStep, 0, 1000)
		if aimFovSlider then
			aimFovSlider:SetValue(newValue)
		else
			aimFov = newValue
			fovCircle.Radius = aimFov
		end
	end
})

Keybinds:Divider({Text = "Safety", Side = "Left"})

Keybinds:Keybind({
	Name = "Panic (Disable All + Hide GUI)", Side = "Left", Value = "NONE", Mouse = false,
	Blacklist = {"W","A","S","D","Slash","Tab","Backspace","Escape","Space","Delete","Unknown","Backquote"},
	Callback = function(_, pressed)
		if not pressed then return end
		if UserInputService:GetFocusedTextBox() then return end
		aiming = false
		currentTarget = nil
		if aimbotToggle then aimbotToggle:SetValue(false) end
		if blatantToggle then blatantToggle:SetValue(false) end
		if triggerBotToggle then triggerBotToggle:SetValue(false) end
		if espToggle then espToggle:SetValue(false) end
		showFovCircle = false
		fovCircle.Visible = false
		setUIVisible(false)
	end
})

--> [< Extras Command Logic >] <--

local function getChar()
	return plr.Character
end

local function getHum()
	local c = getChar()
	return c and c:FindFirstChildOfClass("Humanoid")
end

local function getRoot()
	local c = getChar()
	return c and c:FindFirstChild("HumanoidRootPart")
end

local function startFly()
	local c = getChar()
	if not c then return end
	local root = c:WaitForChild("HumanoidRootPart", 3)
	if not root then return end
	local hum = c:FindFirstChildOfClass("Humanoid")

	local gyro = Instance.new("BodyGyro")
	gyro.P = 9e4
	gyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
	gyro.CFrame = workspace.CurrentCamera.CFrame
	gyro.Parent = root

	local velo = Instance.new("BodyVelocity")
	velo.Velocity = Vector3.zero
	velo.MaxForce = Vector3.new(9e9, 9e9, 9e9)
	velo.Parent = root

	local flyDirs = {fwd=0, bwd=0, left=0, right=0, up=0, down=0}

	local ib = UserInputService.InputBegan:Connect(function(inp, proc)
		if proc then return end
		local k = inp.KeyCode
		if k == Enum.KeyCode.W then flyDirs.fwd = 1
		elseif k == Enum.KeyCode.S then flyDirs.bwd = -1
		elseif k == Enum.KeyCode.A then flyDirs.left = -1
		elseif k == Enum.KeyCode.D then flyDirs.right = 1
		elseif k == Enum.KeyCode.E then flyDirs.up = 1
		elseif k == Enum.KeyCode.Q then flyDirs.down = -1
		end
	end)
	local ie = UserInputService.InputEnded:Connect(function(inp, proc)
		if proc then return end
		local k = inp.KeyCode
		if k == Enum.KeyCode.W then flyDirs.fwd = 0
		elseif k == Enum.KeyCode.S then flyDirs.bwd = 0
		elseif k == Enum.KeyCode.A then flyDirs.left = 0
		elseif k == Enum.KeyCode.D then flyDirs.right = 0
		elseif k == Enum.KeyCode.E then flyDirs.up = 0
		elseif k == Enum.KeyCode.Q then flyDirs.down = 0
		end
	end)

	extrasConnections.fly = {gyro=gyro, velo=velo, ib=ib, ie=ie}

	task.spawn(function()
		while flyEnabled do
			task.wait()
			if not flyEnabled then break end
			local cam = workspace.CurrentCamera
			local fwd   = cam.CFrame.LookVector  * (flyDirs.fwd  + flyDirs.bwd)
			local right = cam.CFrame.RightVector  * (flyDirs.right + flyDirs.left)
			local up    = Vector3.new(0, flyDirs.up + flyDirs.down, 0)
			local moving = (fwd + right + up).Magnitude > 0
			velo.Velocity = (fwd + right + up) * (moving and flySpeed or 0)
			gyro.CFrame = cam.CFrame
			if hum then hum.PlatformStand = true end
		end
		pcall(function() gyro:Destroy() end)
		pcall(function() velo:Destroy() end)
		pcall(function() ib:Disconnect() end)
		pcall(function() ie:Disconnect() end)
		extrasConnections.fly = nil
		local h = getHum()
		if h then h.PlatformStand = false end
	end)
end

local function stopFly()
	flyEnabled = false
	if extrasConnections.fly then
		pcall(function() extrasConnections.fly.gyro:Destroy() end)
		pcall(function() extrasConnections.fly.velo:Destroy() end)
		pcall(function() extrasConnections.fly.ib:Disconnect() end)
		pcall(function() extrasConnections.fly.ie:Disconnect() end)
		extrasConnections.fly = nil
	end
	local h = getHum()
	if h then h.PlatformStand = false end
end

local function startNoclip()
	extrasConnections.noclip = RunService.Stepped:Connect(function()
		pcall(function()
			local c = getChar()
			if not c then return end
			for _, p in ipairs(c:GetDescendants()) do
				if p:IsA("BasePart") then p.CanCollide = false end
			end
		end)
	end)
end

local function stopNoclip()
	if extrasConnections.noclip then
		extrasConnections.noclip:Disconnect()
		extrasConnections.noclip = nil
	end
	pcall(function()
		local c = getChar()
		if not c then return end
		for _, p in ipairs(c:GetDescendants()) do
			if p:IsA("BasePart") then p.CanCollide = true end
		end
	end)
end

local function applyWalkSpeed()
	local h = getHum()
	if h then h.WalkSpeed = walkSpeed end
end

local function applyJumpPower()
	local h = getHum()
	if h then
		h.JumpPower = jumpPower
		h.UseJumpPower = true
	end
end

local function startInfJump()
	extrasConnections.infJump = UserInputService.JumpRequest:Connect(function()
		local h = getHum()
		if h then h:ChangeState(Enum.HumanoidStateType.Jumping) end
	end)
end

local function stopInfJump()
	if extrasConnections.infJump then
		extrasConnections.infJump:Disconnect()
		extrasConnections.infJump = nil
	end
end


plr.CharacterAdded:Connect(function()
	task.wait(0.5)
	if walkSpeed ~= 16 then applyWalkSpeed() end
	if jumpPower ~= 50 then applyJumpPower() end
	if noclipEnabled then
		stopNoclip()
		startNoclip()
	end
	if flyEnabled then
		stopFly()
		flyEnabled = true
		startFly()
	end
end)

--> [< Extras Tab UI >] <--

local flyToggle, noclipToggle, infJumpToggle
local walkSpeedSlider, jumpPowerSlider, flySpeedSlider

Extras:Divider({Text = "Movement", Side = "Left"})

flyToggle = Extras:Toggle({
	Name = "Fly", Side = "Left", Value = flyEnabled,
	Callback = function(Value)
		flyEnabled = Value
		if Value then
			startFly()
		else
			stopFly()
		end
	end
})

noclipToggle = Extras:Toggle({
	Name = "Noclip", Side = "Left", Value = noclipEnabled,
	Callback = function(Value)
		noclipEnabled = Value
		if Value then startNoclip() else stopNoclip() end
	end
})

flySpeedSlider = Extras:Slider({
	Name = "Fly Speed", Side = "Left", Min = 10, Max = 500, Value = flySpeed, Precise = 0, Unit = "",
	Callback = function(Value) flySpeed = Value end
})

walkSpeedSlider = Extras:Slider({
	Name = "Walk Speed", Side = "Left", Min = 8, Max = 500, Value = walkSpeed, Precise = 0, Unit = "",
	Callback = function(Value)
		walkSpeed = Value
		applyWalkSpeed()
	end
})

jumpPowerSlider = Extras:Slider({
	Name = "Jump Power", Side = "Left", Min = 7, Max = 500, Value = jumpPower, Precise = 0, Unit = "",
	Callback = function(Value)
		jumpPower = Value
		applyJumpPower()
	end
})

Extras:Divider({Text = "Character", Side = "Left"})

infJumpToggle = Extras:Toggle({
	Name = "Infinite Jump", Side = "Left", Value = infJumpEnabled,
	Callback = function(Value)
		infJumpEnabled = Value
		if Value then startInfJump() else stopInfJump() end
	end
})

Extras:Divider({Text = "Tools", Side = "Left"})

--> [< Admin Tab >] <--

Admin:Divider({Text = "Config", Side = "Left"})

Admin:Label({Text = "HWID: " .. tostring(HWID):sub(1, 24) .. "...", Side = "Left"})

Admin:Button({
	Name = "Save Config", Side = "Left",
	Callback = function()
		local ok = saveConfig()
		Bracket:Notification({Title = "Phantom Suite", Description = ok and "Config saved!" or "Save failed (no file access)", Duration = 3})
	end
})

Admin:Button({
	Name = "Load Config", Side = "Left",
	Callback = function()
		local cfg = loadConfig()
		if not cfg then
			Bracket:Notification({Title = "Phantom Suite", Description = "No config found for this HWID.", Duration = 3})
			return
		end
		applyConfig(cfg)
		-- Aimbot
		if aimbotToggle    then aimbotToggle:SetValue(aimbotEnabled) end
		if blatantToggle   then blatantToggle:SetValue(blatantEnabled) end
		if triggerBotToggle then triggerBotToggle:SetValue(triggerBotEnabled) end
		if wallCheckToggle then wallCheckToggle:SetValue(wallCheck) end
		-- ESP
		if espToggle       then espToggle:SetValue(espEnabled) end
		-- Extras
		if flyToggle       then flyToggle:SetValue(false) end
		if noclipToggle    then noclipToggle:SetValue(false) end
		if infJumpToggle   then infJumpToggle:SetValue(false) end
		if flySpeedSlider  then flySpeedSlider:SetValue(flySpeed) end
		if walkSpeedSlider then walkSpeedSlider:SetValue(walkSpeed) end
		if jumpPowerSlider then jumpPowerSlider:SetValue(jumpPower) end
		-- Apply speed/jump immediately
		applyWalkSpeed()
		applyJumpPower()
		Bracket:Notification({Title = "Phantom Suite", Description = "Config loaded!", Duration = 3})
	end
})

Admin:Divider({Text = "Admin Tools", Side = "Left"})

Admin:Button({
	Name = "Destroy UI (Stealth)", Side = "Left",
	Callback = function()
		destroyUI()
	end
})

