========================================
PHANTOM SUITE FEATURES CODE
========================================
All feature functions extracted from PhantomSuite.lua
For easy reading and analysis

========================================
FOV CIRCLE FUNCTIONS
========================================

local function createFOVCircle()
    if not drawingAvailable then return end
    
    if fovCircle then
        fovCircle:Remove()
    end
    
    fovCircle = Drawing.new("Circle")
    fovCircle.Radius = aimFov
    fovCircle.Thickness = 1
    fovCircle.Color = fovColor
    fovCircle.Transparency = 1
    fovCircle.Visible = aimbotEnabled
    fovCircle.Position = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
end

local function updateFOVCircle()
    if not fovCircle or not drawingAvailable then return end
    
    fovCircle.Radius = aimFov
    fovCircle.Color = fovColor
    fovCircle.Visible = aimbotEnabled
    fovCircle.Position = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
end

========================================
AIMBOT FUNCTIONS
========================================

local function getClosestPlayer()
    local closest = nil
    local closestDistance = aimbotLockDistance
    
    for _, player in pairs(players:GetPlayers()) do
        if player ~= plr then
            -- Team check
            if teamCheck and player.Team == plr.Team then
                continue
            end
            
            -- Health check
            local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
            if healthCheck and (not humanoid or humanoid.Health < minHealth) then
                continue
            end
            
            -- Distance check
            local character = player.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                local targetPos = character.HumanoidRootPart.Position
                local screenPos, onScreen = camera:WorldToViewportPoint(targetPos)
                
                if onScreen then
                    local distance = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)).Magnitude
                    
                    if distance < closestDistance then
                        -- Wall check
                        if wallCheck then
                            local raycastParams = RaycastParams.new()
                            raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                            raycastParams.FilterDescendantsInstances = {plr.Character, camera}
                            
                            local result = workspace:Raycast(camera.CFrame.Position, (targetPos - camera.CFrame.Position).Unit * aimbotLockDistance, raycastParams)
                            if result and result.Instance and result.Instance:IsDescendantOf(character) then
                                closest = player
                                closestDistance = distance
                            end
                        else
                            closest = player
                            closestDistance = distance
                        end
                    end
                end
            end
        end
    end
    
    return closest
end

========================================
ESP FUNCTIONS
========================================

-- Drawing service detection
local espObjects = {}
local drawingAvailable = false
local Drawing = nil

pcall(function()
    Drawing = Drawing
    if Drawing then
        drawingAvailable = pcall(function() 
            local test = Drawing.new("Circle")
            test:Remove()
        end)
    end
end)

local function createESP(player)
    if not drawingAvailable or not espEnabled then return end
    
    -- Clean up old ESP objects
    if espObjects[player] then
        for _, obj in pairs(espObjects[player]) do
            if obj and obj.Remove then
                obj:Remove()
            end
        end
    end
    
    espObjects[player] = {}
    
    -- Create ESP objects
    if boxEsp then
        local box = Drawing.new("Square")
        box.Thickness = 1
        box.Color = espColor
        box.Transparency = 1
        box.Visible = false
        table.insert(espObjects[player], box)
    end
    
    if nameEsp then
        local name = Drawing.new("Text")
        name.Size = 13
        name.Color = espColor
        name.Center = true
        name.Outline = true
        name.Visible = false
        table.insert(espObjects[player], name)
    end
    
    if healthEsp then
        local healthBar = Drawing.new("Square")
        healthBar.Thickness = 1
        healthBar.Color = Color3.fromRGB(0, 255, 0)
        healthBar.Transparency = 1
        healthBar.Visible = false
        table.insert(espObjects[player], healthBar)
    end
    
    if tracerEsp then
        local tracer = Drawing.new("Line")
        tracer.Thickness = 1
        tracer.Color = espColor
        tracer.Transparency = 1
        tracer.Visible = false
        table.insert(espObjects[player], tracer)
    end
end

local function updateESP(player)
    if not drawingAvailable or not espEnabled or not espObjects[player] then return end
    
    local character = player.Character
    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
    
    if not character or not humanoid or not rootPart then
        -- Hide ESP if character doesn't exist
        for _, obj in pairs(espObjects[player]) do
            if obj and obj.Visible ~= nil then
                obj.Visible = false
            end
        end
        return
    end
    
    -- Team check
    if teamCheck and player.Team == plr.Team then
        for _, obj in pairs(espObjects[player]) do
            if obj and obj.Visible ~= nil then
                obj.Visible = false
            end
        end
        return
    end
    
    local position, onScreen = camera:WorldToViewportPoint(rootPart.Position)
    
    if not onScreen then
        -- Hide ESP if off screen
        for _, obj in pairs(espObjects[player]) do
            if obj and obj.Visible ~= nil then
                obj.Visible = false
            end
        end
        return
    end
    
    -- Update ESP objects
    local objIndex = 1
    
    -- Box ESP
    if boxEsp and espObjects[player][objIndex] then
        local box = espObjects[player][objIndex]
        local size = rootPart.Size.Y * 2
        local scaleFactor = (size / (position.Z * math.tan(math.rad(camera.FieldOfView / 2))))
        
        box.Size = Vector2.new(scaleFactor, scaleFactor * 1.5)
        box.Position = Vector2.new(position.X - box.Size.X / 2, position.Y - box.Size.Y / 2)
        box.Color = espColor
        box.Visible = espEnabled
        objIndex = objIndex + 1
    end
    
    -- Name ESP
    if nameEsp and espObjects[player][objIndex] then
        local name = espObjects[player][objIndex]
        name.Text = player.Name .. " [" .. math.floor((rootPart.Position - plr.Character.HumanoidRootPart.Position).Magnitude) .. "m]"
        name.Position = Vector2.new(position.X, position.Y - 20)
        name.Color = espColor
        name.Visible = espEnabled
        objIndex = objIndex + 1
    end
    
    -- Health ESP
    if healthEsp and espObjects[player][objIndex] then
        local healthBar = espObjects[player][objIndex]
        local healthPercent = humanoid.Health / humanoid.MaxHealth
        
        healthBar.Size = Vector2.new(4, 50)
        healthBar.Position = Vector2.new(position.X - 30, position.Y - 25)
        healthBar.Color = Color3.fromRGB(255 * (1 - healthPercent), 255 * healthPercent, 0)
        healthBar.Visible = espEnabled
        objIndex = objIndex + 1
    end
    
    -- Tracer ESP
    if tracerEsp and espObjects[player][objIndex] then
        local tracer = espObjects[player][objIndex]
        tracer.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
        tracer.To = Vector2.new(position.X, position.Y)
        tracer.Color = espColor
        tracer.Visible = espEnabled
        objIndex = objIndex + 1
    end
end

local function cleanupESP(player)
    if espObjects[player] then
        for _, obj in pairs(espObjects[player]) do
            if obj and obj.Remove then
                obj:Remove()
            end
        end
        espObjects[player] = nil
    end
end

========================================
MOVEMENT FUNCTIONS
========================================

local flyConnection = nil
local noclipConnection = nil
local infJumpConnection = nil

local function startFly()
    if flyConnection then return end
    
    flyConnection = RunService.Heartbeat:Connect(function()
        if not flyEnabled then
            if flyConnection then
                flyConnection:Disconnect()
                flyConnection = nil
            end
            return
        end
        
        local humanoid = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local moveDirection = Vector3.new(
                (UserInputService:IsKeyDown(Enum.KeyCode.W) and 1 or 0) - (UserInputService:IsKeyDown(Enum.KeyCode.S) and 1 or 0),
                (UserInputService:IsKeyDown(Enum.KeyCode.Space) and 1 or 0) - (UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) and 1 or 0),
                (UserInputService:IsKeyDown(Enum.KeyCode.D) and 1 or 0) - (UserInputService:IsKeyDown(Enum.KeyCode.A) and 1 or 0)
            )
            
            if moveDirection ~= Vector3.new(0, 0, 0) then
                humanoid:Move(moveDirection * flySpeed)
            end
        end
    end)
end

local function stopFly()
    flyEnabled = false
    if flyConnection then
        flyConnection:Disconnect()
        flyConnection = nil
    end
end

local function startNoclip()
    if noclipConnection then return end
    
    noclipConnection = RunService.Stepped:Connect(function()
        if not noclipEnabled then
            if noclipConnection then
                noclipConnection:Disconnect()
                noclipConnection = nil
            end
            return
        end
        
        if plr.Character then
            for _, part in pairs(plr.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
end

local function stopNoclip()
    noclipEnabled = false
    if noclipConnection then
        noclipConnection:Disconnect()
        noclipConnection = nil
    end
end

local function startInfJump()
    if infJumpConnection then return end
    
    infJumpConnection = UserInputService.JumpRequest:Connect(function()
        if infJumpEnabled then
            local humanoid = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.Jump = true
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end
    end)
end

local function stopInfJump()
    infJumpEnabled = false
    if infJumpConnection then
        infJumpConnection:Disconnect()
        infJumpConnection = nil
    end
end

========================================
MAIN GAME LOGIC
========================================

local function main()
    -- Create UI
    local Window = createMainUI()
    
    -- Initialize FOV circle
    createFOVCircle()
    
    -- Setup ESP for existing players
    for _, player in pairs(players:GetPlayers()) do
        if player ~= plr then
            createESP(player)
        end
    end
    
    -- Player added event
    players.PlayerAdded:Connect(function(player)
        if player ~= plr then
            createESP(player)
        end
    end)
    
    -- Player removing event
    players.PlayerRemoving:Connect(function(player)
        cleanupESP(player)
    end)
    
    -- Main loops
    task.spawn(function()
        while true do
            task.wait()
            
            -- Update FOV circle
            updateFOVCircle()
            
            -- Aimbot logic
            if aimbotEnabled and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
                local target = getClosestPlayer()
                if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
                    local targetPos = target.Character.HumanoidRootPart.Position
                    
                    -- Apply prediction
                    local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid.MoveDirection ~= Vector3.new(0, 0, 0) then
                        targetPos = targetPos + humanoid.MoveDirection * predictionStrength * 50
                    end
                    
                    if blatantEnabled then
                        -- Blatant Aimlock: Instant snap with no smoothing
                        camera.CFrame = CFrame.new(camera.CFrame.Position, targetPos)
                    else
                        -- Normal Aimbot: Apply smoothing
                        local aimDirection = (targetPos - camera.CFrame.Position).Unit
                        local currentLook = camera.CFrame.LookVector
                        local smoothedDirection = currentLook:Lerp(aimDirection, 1 / smoothing)
                        camera.CFrame = CFrame.new(camera.CFrame.Position, camera.CFrame.Position + smoothedDirection)
                    end
                end
            end
            
            -- Movement logic
            if flyEnabled then
                startFly()
            else
                stopFly()
            end
            
            if noclipEnabled then
                startNoclip()
            else
                stopNoclip()
            end
            
            if infJumpEnabled then
                startInfJump()
            else
                stopInfJump()
            end
            
            -- Apply movement settings
            local humanoid = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = walkSpeed
                humanoid.JumpPower = jumpPower
            end
        end
    end)
    
    -- ESP update loop
    task.spawn(function()
        while true do
            task.wait(0.1) -- Update ESP every 100ms for performance
            
            if espEnabled and drawingAvailable then
                for _, player in pairs(players:GetPlayers()) do
                    if player ~= plr then
                        updateESP(player)
                    end
                end
            end
        end
    end)
end

========================================
KEY VARIABLES
========================================

-- Aimbot Variables
local aimFov = 100
local predictionStrength = 0.065
local smoothing = 5
local aimbotLockDistance = 500
local aimbotEnabled = false
local blatantEnabled = false

-- ESP Variables
local espEnabled = false
local boxEsp = true
local nameEsp = true
local healthEsp = true
local distanceEsp = true
local tracerEsp = false
local espLockDistance = 500

-- Visual Variables
local fovColor = Color3.fromRGB(255, 255, 255)
local espColor = Color3.fromRGB(255, 0, 0)
local fovCircle = nil

-- Check Variables
local wallCheck = true
local teamCheck = true
local stickyAimEnabled = false
local healthCheck = false
local minHealth = 0

-- Movement Variables
local flyEnabled = false
local noclipEnabled = false
local infJumpEnabled = false
local flySpeed = 50
local walkSpeed = 16
local jumpPower = 50

========================================
FEATURES SUMMARY
========================================

1. ADVANCED AIMBOT:
   - Target selection with team/health/wall checks
   - Distance-based targeting
   - Prediction compensation
   - Smooth aiming with adjustable smoothing
   - Blatant aimlock mode (instant snap)
   - FOV circle visualization

2. COMPREHENSIVE ESP:
   - Box ESP with dynamic sizing
   - Name ESP with distance display
   - Health ESP with color-coded bars
   - Tracer ESP from screen center
   - Safe Drawing service detection
   - Automatic cleanup on player removal

3. MOVEMENT TOOLS:
   - Fly with 3D WASD + Space/Control movement
   - Noclip with collision removal
   - Infinite jump with state management
   - Adjustable speed controls
   - Proper connection management

4. PERFORMANCE FEATURES:
   - Optimized ESP updates (100ms intervals)
   - Safe character detection
   - Memory leak prevention
   - Connection pooling and cleanup
   - Error handling with pcall wrappers

5. UI INTEGRATION:
   - Real-time FOV circle updates
   - All controls properly connected
   - Visual feedback for all actions
   - Professional Bracket Library interface

========================================
END OF FEATURES CODE
========================================
